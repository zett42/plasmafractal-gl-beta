(function(e){function t(t){for(var a,r,s=t[0],l=t[1],c=t[2],d=0,h=[];d<s.length;d++)r=s[d],Object.prototype.hasOwnProperty.call(i,r)&&i[r]&&h.push(i[r][0]),i[r]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(e[a]=l[a]);u&&u(t);while(h.length)h.shift()();return o.push.apply(o,c||[]),n()}function n(){for(var e,t=0;t<o.length;t++){for(var n=o[t],a=!0,s=1;s<n.length;s++){var l=n[s];0!==i[l]&&(a=!1)}a&&(o.splice(t--,1),e=r(r.s=n[0]))}return e}var a={},i={app:0},o=[];function r(t){if(a[t])return a[t].exports;var n=a[t]={i:t,l:!1,exports:{}};return e[t].call(n.exports,n,n.exports,r),n.l=!0,n.exports}r.m=e,r.c=a,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)r.d(n,a,function(t){return e[t]}.bind(null,a));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="/plasmafractal-gl-beta/";var s=window["webpackJsonp"]=window["webpackJsonp"]||[],l=s.push.bind(s);s.push=t,s=s.slice();for(var c=0;c<s.length;c++)t(s[c]);var u=l;o.push([0,"chunk-vendors"]),n()})({0:function(e,t,n){e.exports=n("56d7")},"0388":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",[n("b-form-checkbox",{staticClass:"z42opt-check",attrs:{id:e.id,checked:e.value,disabled:e.disabled},on:{change:function(t){return e.$emit("input",t)}}},[e._v(" "+e._s(e.optDesc.$attrs.title)+" ")])],1)},i=[],o=n("ca11"),r={name:"z42opt-check",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{required:!0},optDesc:{type:o["b"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},created:function(){}},s=r,l=n("2877"),c=Object(l["a"])(s,a,i,!1,null,null,null);t["default"]=c.exports},"094b":function(e,t,n){"use strict";n.d(t,"f",(function(){return d})),n.d(t,"e",(function(){return h})),n.d(t,"c",(function(){return f})),n.d(t,"a",(function(){return p})),n.d(t,"d",(function(){return v})),n.d(t,"b",(function(){return m}));n("c975"),n("0d03"),n("b65f"),n("a9e3"),n("b680"),n("4fad"),n("d3b7"),n("acd8"),n("e25e"),n("25f0"),n("ddb0");var a=n("e587"),i=n("9f12"),o=n("53fe"),r=n("8b83"),s=n("c65a"),l=n("c03e"),c=n("ca11"),u=n("66cb");n.d(t,"g",(function(){return c["a"]}));var d=function(e){function t(e){return Object(i["a"])(this,t),Object(r["a"])(this,Object(s["a"])(t).call(this,e))}return Object(l["a"])(t,e),Object(o["a"])(t,[{key:"$serialize",value:function(e){return Math.trunc(e).toString()}},{key:"$deserialize",value:function(e){return e=parseInt(e,10),isNaN(e)?(this.$parseError(e),this.$attrs.defaultVal):_(Math.ceil(e),this.$attrs.min,this.$attrs.max)}},{key:"$displayValue",value:function(e){null!=this.$attrs.displayFactor&&(e*=this.$attrs.displayFactor);var t=Math.trunc(e).toString();return null!=this.$attrs.displayUnit&&(t+=" "+this.$attrs.displayUnit),t}},{key:"$defaultComponent",get:function(){return"z42opt-range"}}]),t}(c["b"]),h=function(e){function t(e){return Object(i["a"])(this,t),Object(r["a"])(this,Object(s["a"])(t).call(this,e))}return Object(l["a"])(t,e),Object(o["a"])(t,[{key:"$serialize",value:function(e){return g(e,this.$attrs.maxDecimals)}},{key:"$deserialize",value:function(e){return e=parseFloat(e),isNaN(e)?(this.$parseError(e),this.$attrs.defaultVal):_(e,this.$attrs.min,this.$attrs.max)}},{key:"$displayValue",value:function(e){null!=this.$attrs.displayFactor&&(e*=this.$attrs.displayFactor),null!=this.$attrs.maxDecimals&&(e=Number(e.toFixed(this.$attrs.maxDecimals)));var t=e.toString();return null!=this.$attrs.displayUnit&&(t+=" "+this.$attrs.displayUnit),t}},{key:"$defaultComponent",get:function(){return"z42opt-range"}}]),t}(c["b"]),f=function(e){function t(e){return Object(i["a"])(this,t),Object(r["a"])(this,Object(s["a"])(t).call(this,e))}return Object(l["a"])(t,e),Object(o["a"])(t,[{key:"$serialize",value:function(e){var t=g(e,this.$attrs.maxDecimals);return t.indexOf(".")<0&&0!==e&&(t+="."),t}},{key:"$deserialize",value:function(e){var t=e.indexOf(".")>=0;return e=parseFloat(e),isNaN(e)?(this.$parseError(e),this.$attrs.defaultVal):(t||(e/=1e3),_(e,this.$attrs.min,this.$attrs.max))}},{key:"$defaultComponent",get:function(){return"z42opt-range"}}]),t}(h),p=function(e){function t(e){return Object(i["a"])(this,t),Object(r["a"])(this,Object(s["a"])(t).call(this,e))}return Object(l["a"])(t,e),Object(o["a"])(t,[{key:"$serialize",value:function(e){return e?"1":"0"}},{key:"$deserialize",value:function(e){var t=e.toString().toLowerCase();return"true"===t||"1"===t}},{key:"$defaultComponent",get:function(){return"z42opt-check"}}]),t}(c["b"]),v=function(e){function t(e){return Object(i["a"])(this,t),Object(r["a"])(this,Object(s["a"])(t).call(this,e))}return Object(l["a"])(t,e),Object(o["a"])(t,[{key:"$serialize",value:function(e){e=String(e).toLowerCase();for(var t=0,n=Object.entries(this.$attrs.values);t<n.length;t++){var i=Object(a["a"])(n[t],2),o=i[0],r=i[1];if(r.shortKey.toLowerCase()===e)return r.shortKey;if(o.toLowerCase()===e)return r.shortKey}return null}},{key:"$deserialize",value:function(e){e=String(e).toLowerCase();for(var t=0,n=Object.entries(this.$attrs.values);t<n.length;t++){var i=Object(a["a"])(n[t],2),o=i[0],r=i[1];if(r.shortKey.toLowerCase()===e)return o;if(o.toLowerCase()===e)return o}return this.$parseError(e),this.$attrs.defaultVal}},{key:"$defaultComponent",get:function(){return"z42opt-select"}}]),t}(c["b"]),m=function(e){function t(e){return Object(i["a"])(this,t),Object(r["a"])(this,Object(s["a"])(t).call(this,e))}return Object(l["a"])(t,e),Object(o["a"])(t,[{key:"$serialize",value:function(e){return u(e).toHex()}},{key:"$deserialize",value:function(e){var t=u(e);return t.isValid()?t.toRgb():(this.$parseError(e),this.$attrs.defaultVal)}},{key:"$defaultComponent",get:function(){return"z42opt-color"}}]),t}(c["b"]);function _(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return t&&e<t?t:n&&e>n?n:e}function g(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return null!=t&&(e=Number(e.toFixed(t))),e=e.toString(),"0"==e.charAt(0)&&"."==e.charAt(1)?e.substring(1):"-"==e.charAt(0)&&"0"==e.charAt(1)&&"."==e.charAt(2)?"-"+e.substring(2):e}},"0954":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",{attrs:{label:e.label,"label-for":e.labelFor,disabled:e.disabled}},[n("canvas",{staticClass:"z42opt-palette-easefun-canvas",attrs:{id:e.easeFunCanvasId}}),n("canvas",{staticClass:"z42opt-palette-gradient-canvas",attrs:{id:e.gradientCanvasId}}),n("div",{staticClass:"z42opt-palette-slider",attrs:{id:e.id,disabled:e.disabled}}),null!==e.selectedHandleIndex?n("z42opt-container",{key:e.selectedPaletteItemId,staticClass:"container px-0",attrs:{id:e.selectedPaletteItemId,optData:e.selectedPaletteItem,optDesc:e.optDesc.segment,optView:e.selectedPaletteItemView},on:{"opt-modified":function(t){return e.onPaletteAttributeInput(t)}}}):e._e(),null===e.selectedHandleIndex?n("div",{staticClass:"text-info"},[n("p",[e._v(" Click handle to "),n("b",[e._v("edit")]),e._v(" properties."),n("br"),e._v(" Curve displays luminance. Change ease functions to modify curve shape. ")]),n("p",[e._v(" Double-click to "),n("b",[e._v("add")]),e._v(" handle."),n("br"),e._v(" Drag up/down or shift+click to "),n("b",[e._v("remove")]),e._v(" handle. ")])]):e._e()],1)},i=[],o=(n("a4d3"),n("e01a"),n("d28b"),n("c740"),n("a630"),n("d81d"),n("4e82"),n("a434"),n("c19f"),n("ace4"),n("b65f"),n("d3b7"),n("3ca3"),n("fb2c"),n("9a8c"),n("a975"),n("735e"),n("c1ac"),n("d139"),n("3a7b"),n("d5d6"),n("82f8"),n("e91f"),n("60bd"),n("5f96"),n("3280"),n("3fcc"),n("ca91"),n("25a1"),n("cd26"),n("3c5d"),n("2954"),n("649e"),n("219c"),n("170b"),n("b39a"),n("72f7"),n("10d1"),n("ddb0"),n("2216")),r=n("4752"),s=n("be4d"),l=n("e9fa"),c=n.n(l),u=n("6dd8"),d=new WeakMap,h=50,f="z42opt-palette-handle-to-remove",p="z42opt-palette-handle-selected",v={name:"z42opt-palette",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{type:Array,required:!0},optDesc:{type:o["a"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},data:function(){return{selectedHandleIndex:null,selectedPaletteItem:null,selectedPaletteItemView:{options:[""]}}},mounted:function(){var e=m(this.value,this.optDesc),t=new u["a"](this.onCanvasResize);d.set(this,{palette:e,currentMousePos:null,slideStartMousePos:null,slidingHandleElement:null,resizeObserver:t});var n={start:y(e),range:{min:0,max:1},step:.001,behaviour:"unconstrained"};null!=this.optDesc.$attrs.step&&(n.step=this.optDesc.$attrs.step),this.recreateSlider(n),this.updateCanvas(),t.observe(document.getElementById(this.gradientCanvasId)),t.observe(document.getElementById(this.easeFunCanvasId)),_.isEqual(e,this.value)||this.emitPaletteInputEvent()},beforeDestroy:function(){var e=d.get(this);window.removeEventListener("mousemove",this.onSlideMouseMove),window.removeEventListener("touchmove",this.onSlideTouchMove),e.resizeObserver.disconnect()},computed:{easeFunCanvasId:function(){return this.id+"#easeFunCanvas"},gradientCanvasId:function(){return this.id+"#gradientCanvas"},selectedPaletteItemId:function(){return this.id+"#segmentOptions"},label:function(){return this.optDesc.$attrs.title?this.optDesc.$attrs.title+":":void 0},labelFor:function(){return this.optDesc.$attrs.title?this.id:void 0}},methods:{getSliderElement:function(){return document.getElementById(this.id)},getSliderWidth:function(){return getSliderElement().offsetWidth},getEaseFunCanvasHeight:function(){return document.getElementById(this.easeFunCanvasId).offsetHeight},recreateSlider:function(e){var t=this,n=this.getSliderElement();n.noUiSlider&&n.noUiSlider.destroy(),c.a.create(n,e),n.noUiSlider.on("start",(function(){return t.onSlideStart.apply(t,arguments)})),n.noUiSlider.on("slide",(function(){return t.onSlide.apply(t,arguments)})),n.noUiSlider.on("end",(function(){return t.onSlideEnd.apply(t,arguments)}));var a=!0,i=!1,o=void 0;try{for(var r,s=n.getElementsByClassName("noUi-connects")[Symbol.iterator]();!(a=(r=s.next()).done);a=!0){var l=r.value;l.addEventListener("dblclick",this.onConnectsDblClick)}}catch(m){i=!0,o=m}finally{try{a||null==s.return||s.return()}finally{if(i)throw o}}var u=!0,d=!1,h=void 0;try{for(var f,p=n.getElementsByClassName("noUi-handle")[Symbol.iterator]();!(u=(f=p.next()).done);u=!0){var v=f.value;v.addEventListener("click",this.onHandleClick),v.addEventListener("focus",this.onHandleFocus)}}catch(m){d=!0,h=m}finally{try{u||null==p.return||p.return()}finally{if(d)throw h}}},onSlide:function(e,t,n,a,i){var o=d.get(this).palette,r=y(o);if(!_.isEqual(r,n)){for(var s in n)o[s].pos=n[s];this.updateCanvas(),this.emitPaletteInputEvent()}},onConnectsDblClick:function(e){var t=0;e.target.clientWidth>0&&(t=e.offsetX/e.target.clientWidth),t=_.clamp(t,0,1);var n=_.cloneDeep(d.get(this).palette),a={pos:t};r["f"](a,this.optDesc.segment),n.push(a),this.setPaletteFromOutside(n),this.setSelectedHandle(n.length-1),this.emitPaletteInputEvent()},onHandleClick:function(e){if(e.shiftKey){e.preventDefault();var t=this.handleIndexFromElement(e.target);t>=0&&this.removeHandleAtIndex(t)}},onSlideStart:function(e,t,n,a,i){var o=d.get(this);o.slideStartMousePos=null,o.slidingHandleElement=this.handleElements()[t],window.addEventListener("mousemove",this.onSlideMouseMove),window.addEventListener("touchmove",this.onSlideTouchMove)},onSlideMouseMove:function(e){this.onSlideMouseTouchMove({x:e.screenX,y:e.screenY})},onSlideTouchMove:function(e){e.changedTouches.length>0&&this.onSlideMouseTouchMove({x:e.changedTouches[0].screenX,y:e.changedTouches[0].screenY})},onSlideMouseTouchMove:function(e){var t=d.get(this);t.currentMousePos=_.clone(e),t.slideStartMousePos||(t.slideStartMousePos=_.clone(e));var n=Math.abs(e.y-t.slideStartMousePos.y);n>h&&t.palette.length>1?t.slidingHandleElement.classList.add(f):t.slidingHandleElement.classList.remove(f)},onSlideEnd:function(e,t,n,a,i){var o=d.get(this);if(o.slidingHandleElement.classList.remove(f),o.slideStartMousePos){var r=Math.abs(o.currentMousePos.y-o.slideStartMousePos.y);r>h&&this.removeHandleAtIndex(t)}window.removeEventListener("mousemove",this.onSlideMouseMove),window.removeEventListener("touchmove",this.onSlideTouchMove)},onHandleFocus:function(e){var t=this.handleIndexFromElement(e.target);if(t>=0){var n=this.handleElements(),a=n[t];if(a&&a.classList.add(p),null!=this.selectedHandleIndex){var i=n[this.selectedHandleIndex];i&&i.classList.remove(p)}this.selectedHandleIndex=t;var o=d.get(this).palette;this.selectedPaletteItem=_.cloneDeep(o[t])}},onPaletteAttributeInput:function(e){if(null!=this.selectedHandleIndex){var t=_.get(this.selectedPaletteItem,e.path);if(!_.isEqual(t,e.value)){_.set(this.selectedPaletteItem,e.path,_.cloneDeep(e.value));var n=d.get(this).palette;_.set(n[this.selectedHandleIndex],e.path,_.cloneDeep(e.value)),this.updateCanvas(),this.emitPaletteInputEvent()}}},onCanvasResize:function(e){var t=!0,n=!1,a=void 0;try{for(var i,o=e[Symbol.iterator]();!(t=(i=o.next()).done);t=!0){var r=i.value,s=r.contentRect,l=s.width*window.devicePixelRatio,c=s.height*window.devicePixelRatio;r.target.width===l&&r.target.height===c||(r.target.width=l,r.target.height=c,this.updateCanvas({isEaseFunCanvas:r.target.id==this.easeFunCanvasId,isGradientCanvas:r.target.id==this.gradientCanvasId}))}}catch(u){n=!0,a=u}finally{try{t||null==o.return||o.return()}finally{if(n)throw a}}},handleElements:function(){return Array.from(this.getSliderElement().getElementsByClassName("noUi-handle"))},handleIndexFromElement:function(e){var t=this.handleElements();return t.findIndex((function(t){return t.contains(e)}))},setPaletteFromOutside:function(e){var t=d.get(this).palette,n=y(e),a=this.getSliderElement().noUiSlider;if(e.length!=t.length){var i=a.options;i.start=n,this.recreateSlider(i)}else a.set(n);d.get(this).palette=e,this.updateCanvas()},removeHandleAtIndex:function(e){var t=d.get(this).palette;if(t.length>1){var n=_.cloneDeep(t);n.splice(e,1),this.setPaletteFromOutside(n),this.setSelectedHandle((e+1)%n.length),this.emitPaletteInputEvent()}},setSelectedHandle:function(e){var t=this.handleElements();t[e].focus()},emitPaletteInputEvent:function(){var e=d.get(this).palette;this.$emit("input",_.cloneDeep(e))},updateCanvas:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{isEaseFunCanvas:!0,isGradientCanvas:!0},t=d.get(this).palette,n=this.optDesc.$resolvePaletteEaseFunctions(t);e.isEaseFunCanvas&&this.updateEaseFunCanvas(n),e.isGradientCanvas&&this.updateGradientCanvas(n)},updateEaseFunCanvas:function(e){var t=document.getElementById(this.easeFunCanvasId),n=t.width,a=t.height;if(0!==n&&0!==a){var i=t.getContext("2d");i.fillStyle="rgba( 0, 0, 0, 0.3 )",i.strokeStyle="rgb( 255, 255, 255 )",i.lineWidth=window.devicePixelRatio,i.clearRect(0,0,n,a),i.fillRect(0,0,n,a);var o=n+1,r=a-2*i.lineWidth,l=new Uint32Array(new ArrayBuffer(o*Uint32Array.BYTES_PER_ELEMENT));s["e"](l,l.length,e),b(i,0,i.lineWidth,o,r,l,w)}},updateGradientCanvas:function(e){var t=document.getElementById(this.gradientCanvasId),n=t.width,a=t.height;if(0!==n&&0!==a){var i=t.getContext("2d"),o=i.createImageData(n,1),r=new Uint32Array(o.data.buffer);s["e"](r,r.length,e);for(var l=0;l<a;++l)i.putImageData(o,0,l)}}},watch:{value:{deep:!0,handler:function(e,t){var n=m(e,this.optDesc),a=d.get(this).palette,i=g(n),o=g(a);_.isEqual(i,o)||this.setPaletteFromOutside(n)}}}};function m(e,t){var n={pos:0};if(r["f"](n,t.segment),!Array.isArray(e)||0===e.length){var a=_.cloneDeep(n);return a.pos=.5,a.color={r:255,g:255,b:255,a:1},[n,a]}for(var i=_.cloneDeep(e),o=0;o<i.length;++o)i[o]=i[o]||{},_.defaultsDeep(i[o],n);return i}function g(e){var t=_.cloneDeep(e);return t.sort((function(e,t){return e.pos-t.pos})),t}function y(e){return e.map((function(e){return e.pos}))}function b(e,t,n,a,i,o,r){var s=Math.trunc(t);n=Math.trunc(n);var l=function(e){return n+i-r(o[e])*i};e.beginPath();var c=l(0);e.moveTo(s,c);for(var u=1;u<a;++u){var d=u,h=l(u);(h!=c||u>=a-1)&&(d-s>1&&e.lineTo(d-1,c),e.lineTo(d,h),s=d,c=h)}e.stroke()}function w(e){var t=e>>16&255,n=e>>8&255,a=255&e;return(.299*t+.587*n+.114*a)/255}var E=v,x=n("2877"),T=Object(x["a"])(E,a,i,!1,null,null,null);t["default"]=T.exports},"11f2":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[e._l(e.optView.options,(function(t){return[e._l(e.resolveOptDesc(t),(function(t){return[e.isAttrTrue(t.node,"depends")&&e.isAncestorEnabled(t.path)?n(t.node.$component,{key:e.childId(t.path),tag:"component",attrs:{disabled:!e.isAttrTrue(t.node,"enabled"),id:e.childId(t.path),optDesc:t.node,value:e.resolveValue(t.path)},on:{input:function(n){return e.onModified(t.path,n)}}}):e._e()]}))]}))],2)},i=[],o=(n("99af"),n("b64b"),n("8a79"),n("ca11")),r=n("4752"),s={name:"z42opt-container",inheritAttrs:!1,props:{id:{type:String,required:!0},optData:{type:Object,required:!0},optDesc:{type:o["a"],required:!0},optView:{type:Object,required:!0}},methods:{childId:function(e){return r["c"](this.id,e,"#")},resolveOptDesc:function(e){if(null==e)return[];var t=0===e.length?this.optDesc:_.get(this.optDesc,e);if(t instanceof o["b"])return[{path:e,node:t}];for(var n=[],a=0,i=Object.keys(t);a<i.length;a++){var s=i[a],l=r["c"](e,s);n=n.concat(this.resolveOptDesc(l))}return n},resolveValue:function(e){return _.get(this.optData,e)},isAttrTrue:function(e,t){var n=e.$attrs[t];return"undefined"===typeof n||("function"===typeof n?n(this.optData,this.optDesc):Boolean(n))},isAncestorEnabled:function(e){var t=e;t.endsWith(".isEnabled")&&(t=r["e"](t));while(t)if(t=r["e"](t),t){var n=this.resolveValue(t+".isEnabled");if(!1===n)return!1}return!0},onModified:function(e,t){var n=_.get(this.optDesc,e);n instanceof o["b"]&&this.$emit("opt-modified",{path:e,value:t})}}},l=s,c=n("2877"),u=Object(c["a"])(l,a,i,!1,null,null,null);t["default"]=u.exports},2216:function(e,t,n){"use strict";n.d(t,"a",(function(){return h}));n("a4d3"),n("e01a"),n("d28b"),n("d81d"),n("d3b7"),n("ac1f"),n("3ca3"),n("1276"),n("ddb0");var a=n("9f12"),i=n("53fe"),o=n("8b83"),r=n("c65a"),s=n("c03e"),l=n("ca11"),c=n("094b"),u=n("4752"),d=n("dcbd"),h=function(e){function t(e){var n;return Object(a["a"])(this,t),n=Object(o["a"])(this,Object(r["a"])(t).call(this,e)),n.position=new c["e"]({min:0,max:1,maxDecimals:3,defaultVal:0}),n.segment=new l["a"]({},{color:new c["b"]({title:"Selected color",defaultVal:{r:0,g:0,b:0,a:1}}),easeFun:new c["d"]({title:"Selected ease function",values:n.$attrs.easeFunctions,defaultVal:n.$attrs.defaultEaseFunction}),isNoisy:new c["a"]({title:"Add noise to lightness (HSL)",defaultVal:!1}),noise:new l["a"]({},{frequency:new c["f"]({shortKey:"f",title:"Frequency",min:1,max:15,maxDecimals:0,defaultVal:2,depends:function(e){return e.isNoisy}}),octaves:new c["f"]({shortKey:"o",title:"Octaves",min:1,max:12,defaultVal:4,depends:function(e){return e.isNoisy}}),gain:new c["e"]({shortKey:"g",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.5,depends:function(e){return e.isNoisy},enabled:function(e){return e.noise.octaves>=2}}),lacunarity:new c["f"]({shortKey:"l",title:"Lacunarity",min:2,max:10,defaultVal:2,depends:function(e){return e.isNoisy},enabled:function(e){return e.noise.octaves>=2}}),amplitude:new c["e"]({shortKey:"a",title:"Amplitude",min:0,max:5,maxDecimals:2,defaultVal:.5,depends:function(e){return e.isNoisy}}),seed:new c["e"]({shortKey:"s",title:"Random seed",min:0,max:1,maxDecimals:2,defaultVal:.5,depends:function(e){return e.isNoisy}})})}),u["g"](n.segment.noise,"palette.noise"),n}return Object(s["a"])(t,e),Object(i["a"])(t,[{key:"$serialize",value:function(e){var t="",n=!0,a=!1,i=void 0;try{for(var o,r=e[Symbol.iterator]();!(n=(o=r.next()).done);n=!0){var s=o.value;if(0===t.length||(t+=" "),t+=this.position.$serialize(s.pos)+"_",t+=this.segment.color.$serialize(s.color)+"_",t+=this.segment.easeFun.$serialize(s.easeFun),s.isNoisy){var l="";for(var c in this.segment.noise){0===l.length||(l+="*");var u=this.segment.noise[c];l+=u.$attrs.shortKey,l+=u.$serialize(s.noise[c])}t+="_"+l}}}catch(d){a=!0,i=d}finally{try{n||null==r.return||r.return()}finally{if(a)throw i}}return t}},{key:"$deserialize",value:function(e){var t=[],n={};u["b"](n,this.segment.noise);var a=!0,i=!1,o=void 0;try{for(var r,s=e.split(" ")[Symbol.iterator]();!(a=(r=s.next()).done);a=!0){var l=r.value,c=l.split("_");if(c.length>=2){var d={pos:this.position.$deserialize(c[0]),color:this.segment.color.$deserialize(c[1]),isNoisy:!1};if(c.length>=3&&(d.easeFun=this.segment.easeFun.$deserialize(c[2])),c.length>=4){d.isNoisy=!0,d.noise={};var h=c[3].split("*");for(var f in h){var p=h[f],v=p.substring(0,1),m=p.substring(1),_=n[v];if(_){var g=this.segment.noise[_].$deserialize(m);null!==g&&(d.noise[_]=g)}else console.error("Invalid shortKey for palette noise option:",v)}}t.push(d)}}}catch(y){i=!0,o=y}finally{try{a||null==s.return||s.return()}finally{if(i)throw o}}return t}},{key:"$resolveEaseFunction",value:function(e){return d[e]||d["linear"]}},{key:"$resolvePaletteEaseFunctions",value:function(e){var t=this;return e.map((function(e){var n=_.cloneDeep(e);return n.easeFun=t.$resolveEaseFunction(n.easeFun),n}))}},{key:"$defaultComponent",get:function(){return"z42opt-palette"}}]),t}(l["b"])},2465:function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",{staticClass:"container px-0"},[n("b-row",{attrs:{"align-v":"center"}},[n("b-col",[n("label",{attrs:{for:e.id,disabled:e.disabled}},[e._v(" "+e._s(e.optDesc.$attrs.title)+": ")])]),n("b-col",[n("b-form-input",{staticClass:"z42opt-color",attrs:{type:"color",id:e.id,value:e.hexValue,disabled:e.disabled},on:{change:function(t){return e.onModified(t)}}})],1)],1)],1)},i=[],o=n("66cb"),r=n("ca11"),s={name:"z42opt-color",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{required:!0},optDesc:{type:r["b"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},created:function(){},computed:{hexValue:function(){return o(this.value).toHexString()}},methods:{onModified:function(e){this.$emit("input",o(e).toRgb())}}},l=s,c=n("2877"),u=Object(c["a"])(l,a,i,!1,null,null,null);t["default"]=u.exports},"357f":function(e,t,n){},4752:function(e,t,n){"use strict";n.d(t,"d",(function(){return s})),n.d(t,"f",(function(){return l})),n.d(t,"c",(function(){return d})),n.d(t,"e",(function(){return h})),n.d(t,"a",(function(){return f})),n.d(t,"g",(function(){return p})),n.d(t,"b",(function(){return m}));n("a4d3"),n("e01a"),n("d28b"),n("99af"),n("a15b"),n("0d03"),n("4ec9"),n("4fad"),n("d3b7"),n("ac1f"),n("25f0"),n("3ca3"),n("1276"),n("ddb0"),n("2b3d");var a=n("bf2d"),i=n("e587"),o=n("ca11"),r=n("2ef0");function s(e,t){var n={};l(n,e),console.log("Default options:",JSON.parse(JSON.stringify(n)));var a=c(t,e);return a?(console.log("URL params:",JSON.parse(JSON.stringify(a))),r["defaultsDeep"](a,n),console.log("Merged options:",JSON.parse(JSON.stringify(a))),a):defaultValues}function l(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(!(t instanceof o["a"]))throw new Error("Invalid argument: descriptor must be instance of z42opt.Node");for(var a=0,s=Object.entries(t);a<s.length;a++){var c=Object(i["a"])(s[a],2),u=c[0],h=c[1],f=d(n,u);if(h instanceof o["b"]){var p=h.$attrs.defaultVal;"undefined"===typeof p&&(console.error("Missing attribute defaultVal for option:",f),p=null),r["set"](e,f,p)}else l(e,h,f)}}function c(e,t){if(!(t instanceof o["a"]))throw new Error("Invalid argument: descriptor must be instance of z42opt.Node");var n={};p(t);var a={};m(a,t);var s=new URLSearchParams(e),l=!0,c=!1,u=void 0;try{for(var d,h=s[Symbol.iterator]();!(l=(d=h.next()).done);l=!0){var f=Object(i["a"])(d.value,2),v=f[0],_=f[1],g=a[v];if("undefined"!==typeof g){var y=r["get"](t,g);if(y instanceof o["b"]){var b=y.$deserialize(_);null!==b&&r["set"](n,g,b)}else console.error("Internal error: missing or invalid descriptor for URL param '".concat(v,"', path: ").concat(g))}else console.error("Invalid URL param '".concat(v,"'"))}}catch(w){c=!0,u=w}finally{try{l||null==h.return||h.return()}finally{if(c)throw u}}return n}function u(e,t){if(!(t instanceof o["a"]))throw new Error("Invalid argument: descriptor must be instance of z42opt.Node");p(t);var n=new URLSearchParams;return _(n,e,t),n.toString()}function d(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:".";return e&&0!=e.length?e+n+t:t}function h(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:".",n=e.split(t);return n.pop(),n.join(t)}function f(e,t,n){var a=u(e,t),i=n.split("#")[0].split("?")[0];return i+"?"+a+"#"}function p(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=new Map;v(n,e,t);var a=!0,o=!1,r=void 0;try{for(var s,l=n.entries()[Symbol.iterator]();!(a=(s=l.next()).done);a=!0){var c=Object(i["a"])(s.value,2),u=c[0],d=c[1];d.length>1&&console.error("Duplicate value '".concat(u,"' of attribute 'shortKey' detected for the following options:"),d)}}catch(h){o=!0,r=h}finally{try{a||null==l.return||l.return()}finally{if(o)throw r}}}function v(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=0,r=Object.entries(t);a<r.length;a++){var s=Object(i["a"])(r[a],2),l=s[0],c=s[1],u=d(n,l);if(c instanceof o["b"]){var h=c.$attrs.shortKey;if(!h){console.error("Missing attribute 'shortKey' for option:",u);continue}var f=h.toLowerCase();if(f!==h){console.error("Attribute 'shortKey' is not all lowercase for option:",u);continue}e.has(h)?e.get(h).push(u):e.set(h,[u])}else v(e,c,u)}}function m(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=0,r=Object.entries(t);a<r.length;a++){var s=Object(i["a"])(r[a],2),l=s[0],c=s[1],u=d(n,l);c instanceof o["b"]?e[c.$attrs.shortKey]=u:m(e,c,u)}}function _(e,t,n){for(var s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,l=0,c=Object.entries(t);l<c.length;l++){var u=Object(i["a"])(c[l],2),h=u[0],f=u[1],p=d(s,h),v=r["get"](n,p);if(v instanceof o["b"]){if(!1!==v.$attrs.serialize){if(!v.$attrs.shortKey){console.error("Missing attribute shortKey for option:",p);continue}var m=v.$serialize(f);e.append(v.$attrs.shortKey,m)}}else"object"===Object(a["a"])(f)?_(e,f,n,p):console.error("Missing descriptor for option:",p)}}},"4af1":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-modal",{attrs:{id:e.id,title:e.optView.title,scrollable:"","hide-footer":""},on:{show:e.onShow,hide:e.onHide}},[n("p",[e.optView.moreInfoLinkUrl?n("a",{attrs:{href:e.optView.moreInfoLinkUrl,target:"_blank",rel:"noopener"}},[e._v(" "+e._s(e.optView.moreInfoLinkText)+" ")]):e._e(),n("a",{staticStyle:{float:"right"},attrs:{href:e.permaLinkUrl}},[e._v("Permalink")])]),n(e.optView.component||"z42opt-tabs",{tag:"component",attrs:{id:e.id,optData:e.optData,optDesc:e.optDesc,optView:e.optView,tabIndex:e.tabIndex},on:{"update:tabIndex":function(t){e.tabIndex=t},"update:tab-index":function(t){e.tabIndex=t},"opt-modified":function(t){return e.$emit("opt-modified",t)}}})],1)},i=[],o=n("ca11"),r=n("4752"),s={name:"z42opt-dialog",inheritAttrs:!1,props:{id:{type:String,required:!0},optData:{type:Object,required:!0},optDesc:{type:o["a"],required:!0},optView:{type:Object,required:!0}},data:function(){return{initialPermaLinkUrl:null,tabIndex:0}},computed:{permaLinkUrl:function(){return r["a"](this.optData,this.optDesc,window.location.href)}},methods:{onShow:function(){this.initialPermaLinkUrl=r["a"](this.optData,this.optDesc,window.location.href)},onHide:function(){this.permaLinkUrl!==this.initialPermaLinkUrl&&window.history.pushState({action:"optionsDialogClose"},document.title,this.permaLinkUrl)}}},l=s,c=n("2877"),u=Object(c["a"])(l,a,i,!1,null,null,null);t["default"]=u.exports},"4fc5":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",{attrs:{label:e.optDesc.$attrs.title+":","label-for":e.id,disabled:e.disabled}},[n("b-form-select",{staticClass:"z42opt-select",attrs:{id:e.id,options:e.options,value:e.value,disabled:e.disabled},on:{change:function(t){return e.$emit("input",t)}}})],1)},i=[],o=(n("d81d"),n("4fad"),n("d3b7"),n("ddb0"),n("ca11")),r={name:"z42opt-select",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{required:!0},optDesc:{type:o["b"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},created:function(){},computed:{options:function(){var e=Object.entries(this.optDesc.$attrs.values);return e.map((function(e){return{value:e[0],text:e[1].title||e[0]}}))}}},s=r,l=n("2877"),c=Object(l["a"])(s,a,i,!1,null,null,null);t["default"]=c.exports},"56d7":function(e,t,n){"use strict";n.r(t);n("e260"),n("e6cf"),n("cca6"),n("a79d");var a=n("2b0e"),i=n("5f5b");n("ab8b"),n("2dd8");a["default"].use(i["a"]);n("4160"),n("d3b7"),n("ac1f"),n("5319"),n("1276"),n("159b"),n("ddb0");var o=n("b8d7");o.keys().forEach((function(e){var t=o(e),n=e.split("/").pop().replace(/\.\w+$/,"");a["default"].component(n,t.default||t)}));var r=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{attrs:{id:"app"}},[n("b-button",{directives:[{name:"b-modal",rawName:"v-b-modal.z42opt-dialog",modifiers:{"z42opt-dialog":!0}}],attrs:{id:"button-options-dialog",title:"Plasma Options (Key 'o')"}},[e._v("⚙")]),n("z42opt-dialog",{attrs:{id:"z42opt-dialog",optData:e.optData,optDesc:e.optDesc,optView:e.optView},on:{"opt-modified":function(t){return e.onModified(t)}}}),e.optData.info.showFps?n("div",{attrs:{id:"fps-info"}}):e._e(),n("canvas",{staticClass:"plasma",attrs:{id:"plasmaCanvas"}},[e._v("PlasmaFractal")])],1)},s=[],l=(n("b680"),n("841c"),n("a4d3"),n("4de4"),n("e439"),n("dbb4"),n("b64b"),n("2fa7")),c=n("094b"),u=n("2216");function d(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function h(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?d(n,!0).forEach((function(t){Object(l["a"])(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):d(n).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var f={linear:{shortKey:"l",title:"Linear"},inQuad:{shortKey:"i2",title:"Quadratic [in]"},outQuad:{shortKey:"o2",title:"Quadratic [out]"},inOutQuad:{shortKey:"io2",title:"Quadratic [in/out]"},inCubic:{shortKey:"i3",title:"Cubic [in]"},outCubic:{shortKey:"o3",title:"Cubic [out]"},inOutCubic:{shortKey:"io3",title:"Cubic [in/out]"},inQuart:{shortKey:"i4",title:"Quartic [in]"},outQuart:{shortKey:"o4",title:"Quartic [out]"},inOutQuart:{shortKey:"io4",title:"Quartic [in/out]"},inQuint:{shortKey:"i5",title:"Quintic [in]"},outQuint:{shortKey:"o5",title:"Quintic [out]"},inOutQuint:{shortKey:"io5",title:"Quintic [in/out]"},inSine:{shortKey:"is",title:"Sine [in]"},outSine:{shortKey:"os",title:"Sine [out]"},inOutSine:{shortKey:"ios",title:"Sine [in/out]"},inOutSine2_3:{shortKey:"ios23",title:"Sine(x) + Sine(x*3)  [in/out]"},inOutSine2_5:{shortKey:"ios25",title:"Sine(x) + Sine(x*5)  [in/out]"},inOutSine2_9:{shortKey:"ios29",title:"Sine(x) + Sine(x*9)  [in/out]"},inOutSine2_13:{shortKey:"ios213",title:"Sine(x) + Sine(x*13) [in/out]"},inExpo:{shortKey:"ie",title:"Exponential [in]"},outExpo:{shortKey:"oe",title:"Exponential [out]"},inOutExpo:{shortKey:"ioe",title:"Exponential [in/out]"},inExpo2:{shortKey:"ie2",title:"Double Exponential [in]"},outExpo2:{shortKey:"oe2",title:"Double Exponential [out]"},inOutExpo2:{shortKey:"ioe2",title:"Double Exponential [in/out]"},inCirc:{shortKey:"ic",title:"Circular [in]"},outCirc:{shortKey:"oc",title:"Circular [out]"},inOutCirc:{shortKey:"ioc",title:"Circular [in/out]"},inBounce:{shortKey:"ib",title:"Bounce [in]"},outBounce:{shortKey:"ob",title:"Bounce [out]"},inOutBounce:{shortKey:"iob",title:"Bounce [in/out]"}},p={Perlin3D:{shortKey:"p3",title:"Perlin"},SimplexPerlin3D:{shortKey:"s3",title:"Simplex"},Value3D:{shortKey:"v3",title:"Value"},Cellular3D:{shortKey:"c3",title:"Cellular"}},v={warpRegular:{shortKey:"r",title:"Regular",hasRotationParam:!1},warpPolar:{shortKey:"p",title:"Polar",hasRotationParam:!0},warpVortex:{shortKey:"v",title:"Vortex",hasRotationParam:!0},warpVortexInverse:{shortKey:"vi",title:"Vortex Inverse",hasRotationParam:!0},warpDerivatives:{shortKey:"d",title:"Derivatives",hasRotationParam:!1}},m=h({},v,{warpDerivativesOrtho:{shortKey:"do",title:"Derivatives Orthogonal",hasRotationParam:!1},warpDerivativesOrthoA:{shortKey:"do2",title:"Derivatives Orthogonal A",hasRotationParam:!1}}),_=new c["g"]({},{noise:new c["g"]({},{noiseFunction:new c["d"]({shortKey:"n",title:"Noise function",values:p,defaultVal:"Perlin3D"}),frequency:new c["e"]({shortKey:"f",title:"Frequency",min:.01,max:15,maxDecimals:2,isScale:!0,scaleNormalPos:.33,defaultVal:1.5}),octaves:new c["e"]({shortKey:"o",title:"Octaves",min:1,max:15,maxDecimals:2,defaultVal:10}),gain:new c["e"]({shortKey:"g",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.5,enabled:function(e){return e.noise.octaves>1}}),lacunarity:new c["e"]({shortKey:"l",title:"Lacunarity",min:1,max:10,maxDecimals:2,defaultVal:2,enabled:function(e){return e.noise.octaves>1}}),angle:new c["e"]({shortKey:"an",title:"Angle",min:0,max:90,maxDecimals:1,defaultVal:0,enabled:function(e){return e.noise.octaves>1}}),amplitude:new c["e"]({shortKey:"a",title:"Amplitude",min:.1,max:50,isScale:!0,scaleNormalPos:.15,maxDecimals:2,defaultVal:1}),isClamp:new c["a"]({shortKey:"c",title:"Clamp",defaultVal:!1})}),warp:new c["g"]({},{isEnabled:new c["a"]({shortKey:"de",title:"Warp the noise",defaultVal:!1}),transformFunction:new c["d"]({shortKey:"wt",title:"Transform function",values:v,defaultVal:"warpVortex"}),noiseFunction:new c["d"]({shortKey:"wn",title:"Noise function",values:p,defaultVal:"Perlin3D"}),frequency:new c["e"]({shortKey:"wf",title:"Frequency",min:.01,max:15,maxDecimals:2,isScale:!0,scaleNormalPos:.33,defaultVal:1.5}),octaves:new c["e"]({shortKey:"wo",title:"Octaves",min:1,max:15,maxDecimals:2,defaultVal:4}),gain:new c["e"]({shortKey:"wg",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.75,enabled:function(e){return e.warp.octaves>1}}),lacunarity:new c["e"]({shortKey:"wl",title:"Lacunarity",min:1,max:10,maxDecimals:2,defaultVal:2,enabled:function(e){return e.warp.octaves>1}}),amplitude:new c["e"]({shortKey:"wa",title:"Amplitude",min:1,max:100,maxDecimals:1,defaultVal:12}),rotation:new c["e"]({shortKey:"wr",title:"Rotation",min:1,max:20,maxDecimals:1,defaultVal:4,depends:function(e){return v[e.warp.transformFunction].hasRotationParam}})}),warp2:new c["g"]({},{isEnabled:new c["a"]({shortKey:"de2",title:"Warp the warp",defaultVal:!1}),transformFunction:new c["d"]({shortKey:"wt2",title:"Transform function",values:v,defaultVal:"warpVortex"}),noiseFunction:new c["d"]({shortKey:"wn2",title:"Noise function",values:p,defaultVal:"SimplexPerlin3D"}),frequency:new c["e"]({shortKey:"wf2",title:"Frequency",min:.01,max:15,maxDecimals:2,isScale:!0,scaleNormalPos:.33,defaultVal:3}),octaves:new c["e"]({shortKey:"wo2",title:"Octaves",min:1,max:15,maxDecimals:2,defaultVal:4}),gain:new c["e"]({shortKey:"wg2",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.55,enabled:function(e){return e.warp2.octaves>1}}),lacunarity:new c["e"]({shortKey:"wl2",title:"Lacunarity",min:1,max:10,maxDecimals:2,defaultVal:2,enabled:function(e){return e.warp2.octaves>1}}),amplitude:new c["e"]({shortKey:"wa2",title:"Amplitude",min:1,max:100,maxDecimals:1,defaultVal:3}),rotation:new c["e"]({shortKey:"wr2",title:"Rotation",min:1,max:20,maxDecimals:1,defaultVal:2,depends:function(e){return v[e.warp2.transformFunction].hasRotationParam}})}),feedback:new c["g"]({},{isEnabled:new c["a"]({shortKey:"fbe",title:"Enable feedback effect",defaultVal:!1}),lockFPS:new c["a"]({shortKey:"fblf",title:"Lock FPS to 60 to ensure same speed on different devices",defaultVal:!0}),blending:new c["g"]({},{inputBrightness:new c["e"]({shortKey:"fbib",title:"Input brightness",min:0,max:1,maxDecimals:3,defaultVal:.02}),feedbackBrightness:new c["e"]({shortKey:"fbb",title:"Feedback brightness",min:0,max:1,maxDecimals:3,defaultVal:.95})}),colorTransform:new c["g"]({},{isEnabled:new c["a"]({shortKey:"fbce",title:"Enable color transform",defaultVal:!1}),hueShift:new c["e"]({shortKey:"fbhs",title:"Hue shift",min:-.1,max:.1,maxDecimals:3,defaultVal:0}),desaturate:new c["e"]({shortKey:"fbds",title:"Desaturate",min:0,max:.3,maxDecimals:3,defaultVal:0})}),transform:new c["g"]({},{isEnabled:new c["a"]({shortKey:"fbte",title:"Enable feedback transform",defaultVal:!1}),translateX:new c["e"]({shortKey:"fbtx",title:"Translate X",min:-1,max:1,maxDecimals:3,defaultVal:0}),translateY:new c["e"]({shortKey:"fbty",title:"Translate Y",min:-1,max:1,maxDecimals:3,defaultVal:0})}),warp:new c["g"]({},{isEnabled:new c["a"]({shortKey:"fbwe",title:"Enable feedback warp",defaultVal:!1}),transformFunction:new c["d"]({shortKey:"fbt",title:"Transform function",values:m,defaultVal:"warpRegular"}),noiseFunction:new c["d"]({shortKey:"fbn",title:"Noise function",values:p,defaultVal:"SimplexPerlin3D"}),frequency:new c["e"]({shortKey:"fbf",title:"Frequency",min:.01,max:15,maxDecimals:2,isScale:!0,scaleNormalPos:.33,defaultVal:3}),octaves:new c["e"]({shortKey:"fbo",title:"Octaves",min:1,max:15,maxDecimals:2,defaultVal:4}),gain:new c["e"]({shortKey:"fbg",title:"Gain",min:.1,max:1,maxDecimals:2,defaultVal:.55,enabled:function(e){return e.feedback.warp.octaves>1}}),lacunarity:new c["e"]({shortKey:"fbl",title:"Lacunarity",min:1,max:10,maxDecimals:2,defaultVal:2,enabled:function(e){return e.feedback.warp.octaves>1}}),amplitude:new c["e"]({shortKey:"fba",title:"Amplitude",min:.01,max:100,maxDecimals:2,isScale:!0,scaleNormalPos:.33,defaultVal:3}),rotation:new c["e"]({shortKey:"fbr",title:"Rotation",min:.01,max:40,maxDecimals:2,defaultVal:2,isScale:!0,scaleNormalPos:.33,depends:function(e){return m[e.feedback.warp.transformFunction].hasRotationParam}})})}),palette:new c["g"]({},{isGrayScale:new c["a"]({shortKey:"pg",title:"Show only grayscale output",defaultVal:!1}),isCustom:new c["a"]({shortKey:"icp",title:"Custom palette",defaultVal:!1,depends:function(e){return!e.palette.isGrayScale}}),easeFunctionBgToFg:new c["d"]({shortKey:"pbf",title:"Background to foreground easing",values:f,defaultVal:"inBounce",depends:function(e){return!e.palette.isCustom&&!e.palette.isGrayScale}}),easeFunctionFgToBg:new c["d"]({shortKey:"pfb",title:"Foreground to background easing",values:f,defaultVal:"outBounce",depends:function(e){return!e.palette.isCustom&&!e.palette.isGrayScale}}),saturation:new c["e"]({shortKey:"ps",title:"Saturation",min:0,max:1,maxDecimals:2,defaultVal:.5,depends:function(e){return!e.palette.isCustom&&!e.palette.isGrayScale}}),brightness:new c["e"]({shortKey:"pb",title:"Brightness",min:0,max:1,maxDecimals:2,defaultVal:1,depends:function(e){return!e.palette.isCustom&&!e.palette.isGrayScale}}),bgColor:new c["b"]({shortKey:"pbg",title:"Background color",defaultVal:{r:0,g:0,b:0,a:1},depends:function(e){return!e.palette.isCustom&&!e.palette.isGrayScale}}),customPalette:new u["a"]({shortKey:"cp",easeFunctions:f,defaultEaseFunction:"linear",defaultVal:[],depends:function(e){return e.palette.isCustom&&!e.palette.isGrayScale}}),isCustomPaletteAnimated:new c["a"]({shortKey:"acp",title:"Animate custom palette (random hue offset)",defaultVal:!1,depends:function(e){return e.palette.isCustom&&!e.palette.isGrayScale}})}),paletteFinal:new c["g"]({},{isEnabled:new c["a"]({shortKey:"pfe",title:"Apply palette to final output (post-processing)",defaultVal:!1}),customPalette:new u["a"]({shortKey:"cpf",easeFunctions:f,defaultEaseFunction:"linear",defaultVal:[]})}),noiseAnim:new c["g"]({},{isEnabled:new c["a"]({shortKey:"inm",title:"Mutate noise",defaultVal:!0}),noiseSpeed:new c["e"]({shortKey:"ns",title:"Noise mutation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.05}),turbulence:new c["e"]({shortKey:"ntu",title:"Noise turbulence",min:1,max:2.5,maxDecimals:2,isSlow:!0,defaultVal:1.85})}),warpAnim:new c["g"]({},{isEnabled:new c["a"]({shortKey:"iwm",title:"Mutate warp",defaultVal:!1,depends:function(e){return e.warp.isEnabled}}),noiseSpeed:new c["e"]({shortKey:"ws",title:"Warp mutation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.05,depends:function(e){return e.warp.isEnabled}}),turbulence:new c["e"]({shortKey:"wtu",title:"Warp turbulence",min:1,max:2.5,maxDecimals:2,isSlow:!0,defaultVal:1.85,depends:function(e){return e.warp.isEnabled}})}),warpAnim2:new c["g"]({},{isEnabled:new c["a"]({shortKey:"iwm2",title:"Mutate warp²",defaultVal:!1,depends:function(e){return e.warp2.isEnabled}}),noiseSpeed:new c["e"]({shortKey:"ws2",title:"Warp² mutation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.05,depends:function(e){return e.warp2.isEnabled}}),turbulence:new c["e"]({shortKey:"wtu2",title:"Warp² turbulence",min:1,max:2.5,maxDecimals:2,isSlow:!0,defaultVal:1.85,depends:function(e){return e.warp2.isEnabled}})}),feedbackAnim:new c["g"]({},{isEnabled:new c["a"]({shortKey:"iwmf",title:"Mutate feedback warp",defaultVal:!1,depends:function(e){return e.feedback.isEnabled&&e.feedback.warp.isEnabled}}),noiseSpeed:new c["e"]({shortKey:"wsf",title:"Feedback warp mutation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.05,depends:function(e){return e.feedback.isEnabled&&e.feedback.warp.isEnabled}}),turbulence:new c["e"]({shortKey:"wtuf",title:"Feedback warp turbulence",min:1,max:2.5,maxDecimals:2,isSlow:!0,defaultVal:1.85,depends:function(e){return e.feedback.isEnabled&&e.feedback.warp.isEnabled}})}),paletteAnim:new c["g"]({},{isRotaEnabled:new c["a"]({shortKey:"ipr",title:"Rotate palette (disabled if Noise > Clamp is set)",defaultVal:!1,enabled:function(e){return!e.noise.isClamp}}),rotaSpeed:new c["e"]({shortKey:"prs",title:"Palette rotation speed",min:0,max:1,maxDecimals:2,isSlow:!0,defaultVal:.1,depends:function(e){return e.paletteAnim.isRotaEnabled&&!e.noise.isClamp}}),transitionDelay:new c["c"]({shortKey:"ptde",title:"Palette transition delay",min:0,max:30,displayUnit:"s",maxDecimals:1,isSlow:!0,defaultVal:10,depends:function(e){return!e.palette.isCustom||e.palette.isCustomPaletteAnimated}}),transitionDuration:new c["c"]({shortKey:"ptd",title:"Palette transition duration",min:.1,max:30,displayUnit:"s",maxDecimals:1,isSlow:!0,defaultVal:5,depends:function(e){return!e.palette.isCustom||e.palette.isCustomPaletteAnimated}})}),info:new c["g"]({},{showFps:new c["a"]({shortKey:"sfp",title:"Show FPS",defaultVal:!1,serialize:!1})})}),g={title:"PlasmaFractal Options",moreInfoLinkUrl:"https://github.com/zett42/plasmafractal-gl",moreInfoLinkText:"GitHub Project",groups:{noiseTab:{title:"Noise",options:["noise"]},warpingTab:{title:"Warp",options:["warp"]},warpingTab2:{title:"Warp²",options:["warp2"]},feedbackTab:{title:"Feedback",options:["feedback"]},paletteTab:{title:"Palette",options:["palette"]},paletteFinalTab:{title:"Palette 2",options:["paletteFinal"]},animTab:{title:"Animation",options:["noiseAnim","warpAnim","warpAnim2","feedbackAnim","paletteAnim"]},infoTab:{title:"Info",options:["info"]}}},y=n("4752"),b=(n("e01a"),n("d28b"),n("b65f"),n("3ca3"),n("9f12")),w=n("53fe"),E=n("2aaf"),x=n.n(E),T=n("66cb"),P=n("2ef0"),O=n("e2a2"),S=n.n(O),I=n("be4d"),R=n("dcbd"),A=(n("ace4"),n("cfc3"),n("9a8c"),n("a975"),n("735e"),n("c1ac"),n("d139"),n("3a7b"),n("d5d6"),n("82f8"),n("e91f"),n("60bd"),n("5f96"),n("3280"),n("3fcc"),n("ca91"),n("25a1"),n("cd26"),n("3c5d"),n("2954"),n("649e"),n("219c"),n("170b"),n("b39a"),n("72f7"),n("28dd")),N=n.n(A);function z(e,t,n,a,i){var o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:e.STATIC_DRAW,r=t,s=t+a,l=n,c=n+i;e.bufferData(e.ARRAY_BUFFER,new Float32Array([r,l,s,l,r,c,r,c,s,l,s,c]),o)}function D(e,t,n,a){return t?t.update(n,a):t=N()(e,n,a),t}n("c19f"),n("5cc6"),n("fb2c");function F(e,t,n,a){t=Math.trunc(t);var i=new ArrayBuffer(4*t),o=new Uint32Array(i);I["e"](o,o.length,n);for(var r=0;t>=1;++r){var s=new Uint8Array(i);e.texImage2D(e.TEXTURE_2D,r,e.RGBA,t,1,0,e.RGBA,e.UNSIGNED_BYTE,s,0);var l=Math.trunc(t/2);if(l>=1){for(var c=new ArrayBuffer(4*l),u=new Uint32Array(c),d=0,h=0;d<l;++d,h+=2){var f=U(o,h-1,a),p=U(o,h+0,a),v=U(o,h+1,a),m=k(M(L([f,p,v]),1/3));u[d]=m.a<<24|m.r<<16|m.g<<8|m.b}i=c,o=u}t=l}e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,a?e.REPEAT:e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR)}function C(e){return{a:e>>24,r:e>>16&255,g:e>>8&255,b:255&e}}function L(e){var t={a:0,r:0,g:0,b:0},n=!0,a=!1,i=void 0;try{for(var o,r=e[Symbol.iterator]();!(n=(o=r.next()).done);n=!0){var s=o.value;t.a+=s.a,t.r+=s.r,t.g+=s.g,t.b+=s.b}}catch(l){a=!0,i=l}finally{try{n||null==r.return||r.return()}finally{if(a)throw i}}return t}function M(e,t){return{a:e.a*t,r:e.r*t,g:e.g*t,b:e.b*t}}function k(e){return{a:Math.round(e.a),r:Math.round(e.r),g:Math.round(e.g),b:Math.round(e.b)}}function U(e,t,n){var a=n?I["c"](t,e.length):I["b"](t,0,e.length-1);return C(e[a])}var H="#version 300 es\n\n#define SHADER_NAME glPlasmaVertexShader.glsl\n\nprecision highp float;\n#define GLSLIFY 1\n\n// Scale factor to adjust for screen aspect ratio and orientation.\nuniform vec2 u_scale;\n\n// An attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer.\nin vec2 a_position;\n\n// Used to pass the noise coordinates to the fragment shader.\nout vec2 noiseCoord;\n// Used to pass the feedback texture coordinates to the fragment shader.\nout vec2 feedbackTexCoord;\n\nvoid main() {\n\n\t// Define position of the current vertex by assigning to global variable gl_Position \n\tgl_Position = vec4( a_position, 0, 1 );\n\n\t// Pass noise coords to the fragment shader.\n\t// The GPU will interpolate this value between points.\n\t// Scale to adjust for screen aspect ratio and orientation.\n\tnoiseCoord = a_position * u_scale;\n\n\t// Pass the texture coordinates to the fragment shader.\n\t// Position coords range from -1.0 to 1.0 -> transform to texture range of 0.0 to 1.0.\n\t// The GPU will interpolate this value between points.\n\tfeedbackTexCoord = a_position * 0.5 + 0.5;\n}",W='#version 300 es\n#define SHADER_NAME glPlasmaFragShader.glsl\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fragment shaders don\'t have a default precision so we need to pick one.\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\n//·············································································································\n// Imports\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat Perlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    // calculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 grad_results_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0 );\n    vec4 grad_results_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 ) * ( vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1 );\n\n    // Classic Perlin Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( grad_results_0, grad_results_1, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float final = dot( res0, blend2.zxzx * blend2.wwyy );\n    return ( final * 1.1547005383792515290182975610039 );  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Perlin Noise 3D Deriv\n//  Return value range of -1.0->1.0, with format vec4( value, xderiv, yderiv, zderiv )\n//\nvec4 DerivPerlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D_Deriv.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hashx0 = fract( Pt * lowz_mod.xxxx );\n    vec4 hashx1 = fract( Pt * highz_mod.xxxx );\n    vec4 hashy0 = fract( Pt * lowz_mod.yyyy );\n    vec4 hashy1 = fract( Pt * highz_mod.yyyy );\n    vec4 hashz0 = fract( Pt * lowz_mod.zzzz );\n    vec4 hashz1 = fract( Pt * highz_mod.zzzz );\n\n    //\tcalculate the gradients\n    vec4 grad_x0 = hashx0 - 0.49999;\n    vec4 grad_y0 = hashy0 - 0.49999;\n    vec4 grad_z0 = hashz0 - 0.49999;\n    vec4 grad_x1 = hashx1 - 0.49999;\n    vec4 grad_y1 = hashy1 - 0.49999;\n    vec4 grad_z1 = hashz1 - 0.49999;\n    vec4 norm_0 = inversesqrt( grad_x0 * grad_x0 + grad_y0 * grad_y0 + grad_z0 * grad_z0 );\n    vec4 norm_1 = inversesqrt( grad_x1 * grad_x1 + grad_y1 * grad_y1 + grad_z1 * grad_z1 );\n    grad_x0 *= norm_0;\n    grad_y0 *= norm_0;\n    grad_z0 *= norm_0;\n    grad_x1 *= norm_1;\n    grad_y1 *= norm_1;\n    grad_z1 *= norm_1;\n\n    //\tcalculate the dot products\n    vec4 dotval_0 = vec2( Pf.x, Pf_min1.x ).xyxy * grad_x0 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y0 + Pf.zzzz * grad_z0;\n    vec4 dotval_1 = vec2( Pf.x, Pf_min1.x ).xyxy * grad_x1 + vec2( Pf.y, Pf_min1.y ).xxyy * grad_y1 + Pf_min1.zzzz * grad_z1;\n\n    //\tC2 Interpolation\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec3 blendDeriv = Pf * Pf * (Pf * (Pf * 30.0 - 60.0) + 30.0);\n\n    //  the following is based off Milo Yips derivation, but modified for parallel execution\n    //  http://stackoverflow.com/a/14141774\n\n    //\tConvert our data to a more parallel format\n    vec4 dotval0_grad0 = vec4( dotval_0.x, grad_x0.x, grad_y0.x, grad_z0.x );\n    vec4 dotval1_grad1 = vec4( dotval_0.y, grad_x0.y, grad_y0.y, grad_z0.y );\n    vec4 dotval2_grad2 = vec4( dotval_0.z, grad_x0.z, grad_y0.z, grad_z0.z );\n    vec4 dotval3_grad3 = vec4( dotval_0.w, grad_x0.w, grad_y0.w, grad_z0.w );\n    vec4 dotval4_grad4 = vec4( dotval_1.x, grad_x1.x, grad_y1.x, grad_z1.x );\n    vec4 dotval5_grad5 = vec4( dotval_1.y, grad_x1.y, grad_y1.y, grad_z1.y );\n    vec4 dotval6_grad6 = vec4( dotval_1.z, grad_x1.z, grad_y1.z, grad_z1.z );\n    vec4 dotval7_grad7 = vec4( dotval_1.w, grad_x1.w, grad_y1.w, grad_z1.w );\n\n    //\tevaluate common constants\n    vec4 k0_gk0 = dotval1_grad1 - dotval0_grad0;\n    vec4 k1_gk1 = dotval2_grad2 - dotval0_grad0;\n    vec4 k2_gk2 = dotval4_grad4 - dotval0_grad0;\n    vec4 k3_gk3 = dotval3_grad3 - dotval2_grad2 - k0_gk0;\n    vec4 k4_gk4 = dotval5_grad5 - dotval4_grad4 - k0_gk0;\n    vec4 k5_gk5 = dotval6_grad6 - dotval4_grad4 - k1_gk1;\n    vec4 k6_gk6 = (dotval7_grad7 - dotval6_grad6) - (dotval5_grad5 - dotval4_grad4) - k3_gk3;\n\n    //\tcalculate final noise + deriv\n    float u = blend.x;\n    float v = blend.y;\n    float w = blend.z;\n    vec4 result = dotval0_grad0\n        + u * ( k0_gk0 + v * k3_gk3 )\n        + v * ( k1_gk1 + w * k5_gk5 )\n        + w * ( k2_gk2 + u * ( k4_gk4 + v * k6_gk6 ) );\n    result.y += dot( vec4( k0_gk0.x, k3_gk3.x * v, vec2( k4_gk4.x, k6_gk6.x * v ) * w ), vec4( blendDeriv.x ) );\n    result.z += dot( vec4( k1_gk1.x, k3_gk3.x * u, vec2( k5_gk5.x, k6_gk6.x * u ) * w ), vec4( blendDeriv.y ) );\n    result.w += dot( vec4( k2_gk2.x, k4_gk4.x * u, vec2( k5_gk5.x, k6_gk6.x * u ) * v ), vec4( blendDeriv.z ) );\n    return result * 1.1547005383792515290182975610039;  // scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This is a modified version of Stefan Gustavson\'s and Ian McEwan\'s work at http://github.com/ashima/webgl-noise\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - space scaled can have an approx feature size of 1.0\n//  - filter kernel changed to fix discontinuities at tetrahedron boundaries\n//\n\n//\n//  Simplex Perlin Noise 3D\n//  Return value range of -1.0->1.0\n//\nfloat SimplexPerlin3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHADRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tevaluate gradients\n    vec4 grad_results = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 ) * ( hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 kernel_weights = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    kernel_weights = max(0.5 - kernel_weights, 0.0);\n    kernel_weights = kernel_weights*kernel_weights*kernel_weights;\n\n    //\tsum with the kernel and return\n    return dot( kernel_weights, grad_results ) * FINAL_NORMALIZATION;\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This is a modified version of Stefan Gustavson\'s and Ian McEwan\'s work at http://github.com/ashima/webgl-noise\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - space scaled can have an approx feature size of 1.0\n//  - filter kernel changed to fix discontinuities at tetrahedron boundaries\n//\n\n//\n//  Simplex Perlin Noise 3D Deriv\n//  Return value range of -1.0->1.0, with format vec4( value, xderiv, yderiv, zderiv )\n//\nvec4 DerivSimplexPerlin3D(vec3 P)\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin3D_Deriv.glsl\n\n    //  simplex math constants\n    const float SKEWFACTOR = 1.0/3.0;\n    const float UNSKEWFACTOR = 1.0/6.0;\n    const float SIMPLEX_CORNER_POS = 0.5;\n    const float SIMPLEX_TETRAHADRON_HEIGHT = 0.70710678118654752440084436210485;    // sqrt( 0.5 )\n\n    //  establish our grid cell.\n    P *= SIMPLEX_TETRAHADRON_HEIGHT;    // scale space so we can have an approx feature size of 1.0\n    vec3 Pi = floor( P + dot( P, vec3( SKEWFACTOR) ) );\n\n    //  Find the vectors to the corners of our simplex tetrahedron\n    vec3 x0 = P - Pi + dot(Pi, vec3( UNSKEWFACTOR ) );\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 Pi_1 = min( g.xyz, l.zxy );\n    vec3 Pi_2 = max( g.xyz, l.zxy );\n    vec3 x1 = x0 - Pi_1 + UNSKEWFACTOR;\n    vec3 x2 = x0 - Pi_2 + SKEWFACTOR;\n    vec3 x3 = x0 - SIMPLEX_CORNER_POS;\n\n    //  pack them into a parallel-friendly arrangement\n    vec4 v1234_x = vec4( x0.x, x1.x, x2.x, x3.x );\n    vec4 v1234_y = vec4( x0.y, x1.y, x2.y, x3.y );\n    vec4 v1234_z = vec4( x0.z, x1.z, x2.z, x3.z );\n\n    // clamp the domain of our grid cell\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    //\tgenerate the random vectors\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    vec4 V1xy_V2xy = mix( Pt.xyxy, Pt.zwzw, vec4( Pi_1.xy, Pi_2.xy ) );\n    Pt = vec4( Pt.x, V1xy_V2xy.xz, Pt.z ) * vec4( Pt.y, V1xy_V2xy.yw, Pt.w );\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi.zzz * ZINC.xyz ) );\n    vec3 highz_mods = vec3( 1.0 / ( SOMELARGEFLOATS.xyz + Pi_inc1.zzz * ZINC.xyz ) );\n    Pi_1 = ( Pi_1.z < 0.5 ) ? lowz_mods : highz_mods;\n    Pi_2 = ( Pi_2.z < 0.5 ) ? lowz_mods : highz_mods;\n    vec4 hash_0 = fract( Pt * vec4( lowz_mods.x, Pi_1.x, Pi_2.x, highz_mods.x ) ) - 0.49999;\n    vec4 hash_1 = fract( Pt * vec4( lowz_mods.y, Pi_1.y, Pi_2.y, highz_mods.y ) ) - 0.49999;\n    vec4 hash_2 = fract( Pt * vec4( lowz_mods.z, Pi_1.z, Pi_2.z, highz_mods.z ) ) - 0.49999;\n\n    //\tnormalize random gradient vectors\n    vec4 norm = inversesqrt( hash_0 * hash_0 + hash_1 * hash_1 + hash_2 * hash_2 );\n    hash_0 *= norm;\n    hash_1 *= norm;\n    hash_2 *= norm;\n\n    //\tevaluate gradients\n    vec4 grad_results = hash_0 * v1234_x + hash_1 * v1234_y + hash_2 * v1234_z;\n\n    //  evaulate the kernel weights ( use (0.5-x*x)^3 instead of (0.6-x*x)^4 to fix discontinuities )\n    vec4 m = v1234_x * v1234_x + v1234_y * v1234_y + v1234_z * v1234_z;\n    m = max(0.5 - m, 0.0);\n    vec4 m2 = m*m;\n    vec4 m3 = m*m2;\n\n    //  calc the derivatives\n    vec4 temp = -6.0 * m2 * grad_results;\n    float xderiv = dot( temp, v1234_x ) + dot( m3, hash_0 );\n    float yderiv = dot( temp, v1234_y ) + dot( m3, hash_1 );\n    float zderiv = dot( temp, v1234_z ) + dot( m3, hash_2 );\n\n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION = 37.837227241611314102871574478976;\n\n    //  sum and return all results as a vec3\n    return vec4( dot( m3, grad_results ), xderiv, yderiv, zderiv ) * FINAL_NORMALIZATION;\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Value Noise 3D\n//  Return value range of -1.0->1.0 (modification by zett42, original code: 0.0->1.0)\n//\nfloat Value3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );\n    float result = dot( res0, blend2.zxzx * blend2.wwyy );\n\t\n\treturn result * 2.0 - 1.0;\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  Value Noise 3D Deriv\n//  Return value range of 0.0->1.0, with format vec4( value, xderiv, yderiv, zderiv )\n//\nvec4 DerivValue3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D_Deriv.glsl\n\n    // establish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n    vec3 Pf_min1 = Pf - 1.0;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );\n    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );\n    vec4 hash_highz = fract( Pt * hash_mod.yyyy );\n\n    //\tblend the results and return\n    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);\n    vec3 blendDeriv = Pf * Pf * (Pf * (Pf * 30.0 - 60.0) + 30.0);\n    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );\n    vec4 res1 = mix( res0.xyxz, res0.zwyw, blend.yyxx );\n    vec4 res3 = mix( vec4( hash_lowz.xy, hash_highz.xy ), vec4( hash_lowz.zw, hash_highz.zw ), blend.y );\n    vec2 res4 = mix( res3.xz, res3.yw, blend.x );\n    return vec4( res1.x, 0.0, 0.0, 0.0 ) + ( vec4( res1.yyw, res4.y ) - vec4( res1.xxz, res4.x ) ) * vec4( blend.x, blendDeriv );\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This represents a modified version of Stefan Gustavson\'s work at http://www.itn.liu.se/~stegu/GLSL-cellular\n//  The noise is optimized to use a 2x2x2 search window instead of 3x3x3\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - random point offset is restricted to prevent artifacts\n//\n\n//\n//  Cellular Noise 3D\n//  produces a range of 0.0->1.0\n//\nfloat Cellular3D(vec3 P)\n{\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash ( over -1.0->1.0 range )\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hash_x0 = fract( Pt * lowz_mod.xxxx ) * 2.0 - 1.0;\n    vec4 hash_x1 = fract( Pt * highz_mod.xxxx ) * 2.0 - 1.0;\n    vec4 hash_y0 = fract( Pt * lowz_mod.yyyy ) * 2.0 - 1.0;\n    vec4 hash_y1 = fract( Pt * highz_mod.yyyy ) * 2.0 - 1.0;\n    vec4 hash_z0 = fract( Pt * lowz_mod.zzzz ) * 2.0 - 1.0;\n    vec4 hash_z1 = fract( Pt * highz_mod.zzzz ) * 2.0 - 1.0;\n\n    //  generate the 8 point positions\n    const float JITTER_WINDOW = 0.166666666;\t// 0.166666666 will guarentee no artifacts.\n    hash_x0 = ( ( hash_x0 * hash_x0 * hash_x0 ) - sign( hash_x0 ) ) * JITTER_WINDOW + vec4( 0.0, 1.0, 0.0, 1.0 );\n    hash_y0 = ( ( hash_y0 * hash_y0 * hash_y0 ) - sign( hash_y0 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 1.0, 1.0 );\n    hash_x1 = ( ( hash_x1 * hash_x1 * hash_x1 ) - sign( hash_x1 ) ) * JITTER_WINDOW + vec4( 0.0, 1.0, 0.0, 1.0 );\n    hash_y1 = ( ( hash_y1 * hash_y1 * hash_y1 ) - sign( hash_y1 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 1.0, 1.0 );\n    hash_z0 = ( ( hash_z0 * hash_z0 * hash_z0 ) - sign( hash_z0 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 0.0, 0.0 );\n    hash_z1 = ( ( hash_z1 * hash_z1 * hash_z1 ) - sign( hash_z1 ) ) * JITTER_WINDOW + vec4( 1.0, 1.0, 1.0, 1.0 );\n\n    //\treturn the closest squared distance\n    vec4 dx1 = Pf.xxxx - hash_x0;\n    vec4 dy1 = Pf.yyyy - hash_y0;\n    vec4 dz1 = Pf.zzzz - hash_z0;\n    vec4 dx2 = Pf.xxxx - hash_x1;\n    vec4 dy2 = Pf.yyyy - hash_y1;\n    vec4 dz2 = Pf.zzzz - hash_z1;\n    vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;\n    vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;\n    d1 = min(d1, d2);\n    d1.xy = min(d1.xy, d1.wz);\n    return min(d1.x, d1.y) * ( 9.0 / 12.0 ); // return a value scaled to 0.0->1.0\n}\n\n//\n//  Wombat\n//  An efficient texture-free GLSL procedural noise library\n//  Source: https://github.com/BrianSharpe/Wombat\n//  Derived from: https://github.com/BrianSharpe/GPU-Noise-Lib\n//\n//  I\'m not one for copyrights.  Use the code however you wish.\n//  All I ask is that credit be given back to the blog or myself when appropriate.\n//  And also to let me know if you come up with any changes, improvements, thoughts or interesting uses for this stuff. :)\n//  Thanks!\n//\n//  Brian Sharpe\n//  brisharpe CIRCLE_A yahoo DOT com\n//  http://briansharpe.wordpress.com\n//  https://github.com/BrianSharpe\n//\n\n//\n//  This represents a modified version of Stefan Gustavson\'s work at http://www.itn.liu.se/~stegu/GLSL-cellular\n//  The noise is optimized to use a 2x2x2 search window instead of 3x3x3\n//  Modifications are...\n//  - faster random number generation\n//  - analytical final normalization\n//  - random point offset is restricted to prevent artifacts\n//\n\n//\n//  Cellular Noise 3D Deriv\n//  Return value range of 0.0->1.0, with format vec4( value, xderiv, yderiv, zderiv )\n//\nvec4 DerivCellular3D( vec3 P )\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Cellular3D_Deriv.glsl\n\n    //\testablish our grid cell and unit position\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // clamp the domain\n    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;\n    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );\n\n    // calculate the hash ( over -1.0->1.0 range )\n    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;\n    Pt *= Pt;\n    Pt = Pt.xzxz * Pt.yyww;\n    const vec3 SOMELARGEFLOATS = vec3( 635.298681, 682.357502, 668.926525 );\n    const vec3 ZINC = vec3( 48.500388, 65.294118, 63.934599 );\n    vec3 lowz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi.zzz * ZINC ) );\n    vec3 highz_mod = vec3( 1.0 / ( SOMELARGEFLOATS + Pi_inc1.zzz * ZINC ) );\n    vec4 hash_x0 = fract( Pt * lowz_mod.xxxx ) * 2.0 - 1.0;\n    vec4 hash_x1 = fract( Pt * highz_mod.xxxx ) * 2.0 - 1.0;\n    vec4 hash_y0 = fract( Pt * lowz_mod.yyyy ) * 2.0 - 1.0;\n    vec4 hash_y1 = fract( Pt * highz_mod.yyyy ) * 2.0 - 1.0;\n    vec4 hash_z0 = fract( Pt * lowz_mod.zzzz ) * 2.0 - 1.0;\n    vec4 hash_z1 = fract( Pt * highz_mod.zzzz ) * 2.0 - 1.0;\n\n    //  generate the 8 point positions\n    const float JITTER_WINDOW = 0.166666666;\t// 0.166666666 will guarentee no artifacts.\n    hash_x0 = ( ( hash_x0 * hash_x0 * hash_x0 ) - sign( hash_x0 ) ) * JITTER_WINDOW + vec4( 0.0, 1.0, 0.0, 1.0 );\n    hash_y0 = ( ( hash_y0 * hash_y0 * hash_y0 ) - sign( hash_y0 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 1.0, 1.0 );\n    hash_x1 = ( ( hash_x1 * hash_x1 * hash_x1 ) - sign( hash_x1 ) ) * JITTER_WINDOW + vec4( 0.0, 1.0, 0.0, 1.0 );\n    hash_y1 = ( ( hash_y1 * hash_y1 * hash_y1 ) - sign( hash_y1 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 1.0, 1.0 );\n    hash_z0 = ( ( hash_z0 * hash_z0 * hash_z0 ) - sign( hash_z0 ) ) * JITTER_WINDOW + vec4( 0.0, 0.0, 0.0, 0.0 );\n    hash_z1 = ( ( hash_z1 * hash_z1 * hash_z1 ) - sign( hash_z1 ) ) * JITTER_WINDOW + vec4( 1.0, 1.0, 1.0, 1.0 );\n\n    //\treturn the closest squared distance + derivatives ( thanks to Jonathan Dupuy )\n    vec4 dx1 = Pf.xxxx - hash_x0;\n    vec4 dy1 = Pf.yyyy - hash_y0;\n    vec4 dz1 = Pf.zzzz - hash_z0;\n    vec4 dx2 = Pf.xxxx - hash_x1;\n    vec4 dy2 = Pf.yyyy - hash_y1;\n    vec4 dz2 = Pf.zzzz - hash_z1;\n    vec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1;\n    vec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2;\n    vec4 r1 = d1.x < d1.y ? vec4( d1.x, dx1.x, dy1.x, dz1.x ) : vec4( d1.y, dx1.y, dy1.y, dz1.y );\n    vec4 r2 = d1.z < d1.w ? vec4( d1.z, dx1.z, dy1.z, dz1.z ) : vec4( d1.w, dx1.w, dy1.w, dz1.w );\n    vec4 r3 = d2.x < d2.y ? vec4( d2.x, dx2.x, dy2.x, dz2.x ) : vec4( d2.y, dx2.y, dy2.y, dz2.y );\n    vec4 r4 = d2.z < d2.w ? vec4( d2.z, dx2.z, dy2.z, dz2.z ) : vec4( d2.w, dx2.w, dy2.w, dz2.w );\n    vec4 t1 = r1.x < r2.x ? r1 : r2;\n    vec4 t2 = r3.x < r4.x ? r3 : r4;\n    return ( t1.x < t2.x ? t1 : t2 ) * vec4( 1.0, vec3( 2.0 ) ) * ( 9.0 / 12.0 ); // return a value scaled to 0.0->1.0\n}\n\n// Common parameter types\nstruct FbmNoiseParams {\n\tint   octaves;           // number of octaves for fractal noise\n\tfloat octavesFract;      // fractional part of octaves value\n\tfloat frequency;         // noise frequency\n\tfloat gain;              // amplitude factor per octave\n\tfloat angle;             // rotation per octave\n\tfloat lacunarity;        // frequency factor per octave\n\tfloat turbulence;        // Z coordinate factor per octave  \n};\n\nstruct NoiseParams {\n\tFbmNoiseParams basic;    // basic params\n\tfloat anim;              // Z-position in 3D noise, for animation\n\tfloat amplitude;         // noise amplitude\n};\n\nstruct WarpParams {\n\tFbmNoiseParams basic;\n\tfloat anim;              // Z-position in 3D noise, for animation\n\tfloat amplitude;         // directional amplitude\n\tfloat rotation;          // rotational amplitude\n};\n\n// Through preprocessor variables which are passed from JS via injectDefines(), we select from the above noise functions\n// to compose the FBM functions.\n// NOTE: whitespace within require() should not be changed, as glslify breaks when more than 1 space character appears after comma!\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nfloat fbmNoise3D_1( vec3 pos, FbmNoiseParams noise ) {\n\n\tfloat result = 0.0;\n\tfloat amp    = 1.0;\n\tfloat z      = pos.z;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tresult += BASE_NOISE_FUN( vec3( p, z ) ) * amp;\n\n\t\tp   *= rot * noise.lacunarity;\n\t\tamp *= noise.gain;\n\t\tz   += zInc;\n\t\tz   *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tresult += BASE_NOISE_FUN( vec3( p, z ) ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n//·············································································································\n// Noise and transform functions for warp\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nfloat fbmNoise3D_0( vec3 pos, FbmNoiseParams noise ) {\n\n\tfloat result = 0.0;\n\tfloat amp    = 1.0;\n\tfloat z      = pos.z;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tresult += WARP_NOISE_FUN( vec3( p, z ) ) * amp;\n\n\t\tp   *= rot * noise.lacunarity;\n\t\tamp *= noise.gain;\n\t\tz   += zInc;\n\t\tz   *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tresult += WARP_NOISE_FUN( vec3( p, z ) ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// This variant returns two different noise values for a given coordinate.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nvec2 fbmNoiseDual3D_1( vec3 pos, FbmNoiseParams noise ) {\n\n\tvec2 result = vec2( 0 );\n\n\tfloat freq = noise.frequency;\n\tfloat z    = pos.z;\n\tfloat amp  = 1.0;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.0;\n\n\t// Randomize noise for Y direction.\n\tconst float yInc = 4.8;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tvec3 p = vec3( pos.xy * freq, z );\n\t\tfloat nx = WARP_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\t\tfloat ny = WARP_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\t\tresult += vec2( nx, ny ) * amp;\n\n\t\tfreq   *= noise.lacunarity;\n\t\tamp    *= noise.gain;\n\t\tz      += zInc;\n\t\tz      *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tvec3 p = vec3( pos.xy * freq, z );\n\tfloat nx = WARP_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\tfloat ny = WARP_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\tresult += vec2( nx, ny ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise and derivatives.\n// This variant also returns the accumulated noise (x) aswell as derivatives of the noise function (yzw), \n// for a given coordinate.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nvec4 fmbNoiseDeriv3D_2( vec3 pos, FbmNoiseParams noise ) {\n\n\tvec4 result = vec4( .0, .0, .0, .0 );\n\tfloat amp   = 1.0;\n\tfloat freq  = 1.0;\n\tfloat z     = pos.z;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n        // Calculate noise (x) and derivatives (y, z, w)\n        vec4 n = WARP_NOISE_DERIV_FUN( vec3( p, z ) ) * amp;\n\n\t\tresult.x   += n.x;           // accumulate noise\n        result.yzw += n.yzw * freq;  // accumulate derivatives \n\n\t\tp    *= rot * noise.lacunarity;\n\t\tamp  *= noise.gain;\n        freq *= noise.lacunarity;\n\t\tz    += zInc;\n\t\tz    *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\n    vec4 n = WARP_NOISE_DERIV_FUN( vec3( p, z ) ) * amp * noise.octavesFract;\n\n    result.x   += n.x;           // accumulate noise\n    result.yzw += n.yzw * freq;  // accumulate derivatives \n\n\treturn result;\n}\n\n// Regular domain warping. Just offset coordinates by noise values.\n\nvec2 warpRegular_0( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_1( vec3( pos, warp.anim ), warp.basic );\n\t\t\t\t\t\t\t\t\t  \n\treturn pos + noise * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are interpreting the noise values as angle and length to\n// produce more fluid-looking results. \n\nvec2 warpPolar_0( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_1( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat warpAngle = noise.x * warp.rotation;\n\treturn pos.xy + vec2( sin( warpAngle ), cos( warpAngle ) ) * noise.y * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are using the noise value for a vortex (spiral) transformation.\n// Creates results similar to warpPolar, but requires only a single noise function, reducing GPU load!\n\nvec2 warpVortex_2( vec2 pos, WarpParams warp ) {\n\t\n\tfloat noise = fbmNoise3D_0( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n// Variation of warpVortex. \n\nvec2 warpVortexInverse_2( vec2 pos, WarpParams warp ) {\n\n\tfloat noise = fbmNoise3D_0( vec3( pos, warp.anim ), warp.basic );\n\n\tnoise = 1.0 - abs( clamp( noise, -1.0, 1.0 ) );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n// Domain warping by noise derivatives.\n\nvec2 warpDerivatives_1( vec2 pos, WarpParams warp ) {\n\n\tvec4 noise = fmbNoiseDeriv3D_2( vec3( pos, warp.anim ), warp.basic );\n    \n    // noise.x   = noise value\n    // noise.yzw = derivatives (x,y,z)\n    vec2 deriv = vec2( noise.y, noise.z );\n\n\treturn pos + deriv * warp.amplitude;\n}\n\n// Wrapper functions so we can select from the functions at runtime, without having to know the suffix\n// that is added by glslify to the \'require\'d functions, which it does to avoid duplicate identifiers.\nvec2 warpRegular( vec2 pos, WarpParams warp )        { return warpRegular_0( pos, warp ); }\nvec2 warpPolar( vec2 pos, WarpParams warp )          { return warpPolar_0( pos, warp ); }\nvec2 warpVortex( vec2 pos, WarpParams warp )         { return warpVortex_2( pos, warp ); }\nvec2 warpVortexInverse( vec2 pos, WarpParams warp )  { return warpVortexInverse_2( pos, warp ); }\nvec2 warpDerivatives( vec2 pos, WarpParams warp )    { return warpDerivatives_1( pos, warp ); }\n\n//·············································································································\n// Noise and transform functions for warp2\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nfloat fbmNoise3D_3( vec3 pos, FbmNoiseParams noise ) {\n\n\tfloat result = 0.0;\n\tfloat amp    = 1.0;\n\tfloat z      = pos.z;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tresult += WARP2_NOISE_FUN( vec3( p, z ) ) * amp;\n\n\t\tp   *= rot * noise.lacunarity;\n\t\tamp *= noise.gain;\n\t\tz   += zInc;\n\t\tz   *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tresult += WARP2_NOISE_FUN( vec3( p, z ) ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// This variant returns two different noise values for a given coordinate.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nvec2 fbmNoiseDual3D_0( vec3 pos, FbmNoiseParams noise ) {\n\n\tvec2 result = vec2( 0 );\n\n\tfloat freq = noise.frequency;\n\tfloat z    = pos.z;\n\tfloat amp  = 1.0;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.0;\n\n\t// Randomize noise for Y direction.\n\tconst float yInc = 4.8;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tvec3 p = vec3( pos.xy * freq, z );\n\t\tfloat nx = WARP2_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\t\tfloat ny = WARP2_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\t\tresult += vec2( nx, ny ) * amp;\n\n\t\tfreq   *= noise.lacunarity;\n\t\tamp    *= noise.gain;\n\t\tz      += zInc;\n\t\tz      *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tvec3 p = vec3( pos.xy * freq, z );\n\tfloat nx = WARP2_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\tfloat ny = WARP2_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\tresult += vec2( nx, ny ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise and derivatives.\n// This variant also returns the accumulated noise (x) aswell as derivatives of the noise function (yzw), \n// for a given coordinate.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nvec4 fmbNoiseDeriv3D_0( vec3 pos, FbmNoiseParams noise ) {\n\n\tvec4 result = vec4( .0, .0, .0, .0 );\n\tfloat amp   = 1.0;\n\tfloat freq  = 1.0;\n\tfloat z     = pos.z;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n        // Calculate noise (x) and derivatives (y, z, w)\n        vec4 n = WARP2_NOISE_DERIV_FUN( vec3( p, z ) ) * amp;\n\n\t\tresult.x   += n.x;           // accumulate noise\n        result.yzw += n.yzw * freq;  // accumulate derivatives \n\n\t\tp    *= rot * noise.lacunarity;\n\t\tamp  *= noise.gain;\n        freq *= noise.lacunarity;\n\t\tz    += zInc;\n\t\tz    *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\n    vec4 n = WARP2_NOISE_DERIV_FUN( vec3( p, z ) ) * amp * noise.octavesFract;\n\n    result.x   += n.x;           // accumulate noise\n    result.yzw += n.yzw * freq;  // accumulate derivatives \n\n\treturn result;\n}\n\n// Regular domain warping. Just offset coordinates by noise values.\n\nvec2 warpRegular_1( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_0( vec3( pos, warp.anim ), warp.basic );\n\t\t\t\t\t\t\t\t\t  \n\treturn pos + noise * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are interpreting the noise values as angle and length to\n// produce more fluid-looking results. \n\nvec2 warpPolar_1( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_0( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat warpAngle = noise.x * warp.rotation;\n\treturn pos.xy + vec2( sin( warpAngle ), cos( warpAngle ) ) * noise.y * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are using the noise value for a vortex (spiral) transformation.\n// Creates results similar to warpPolar, but requires only a single noise function, reducing GPU load!\n\nvec2 warpVortex_0( vec2 pos, WarpParams warp ) {\n\t\n\tfloat noise = fbmNoise3D_3( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n// Variation of warpVortex. \n\nvec2 warpVortexInverse_1( vec2 pos, WarpParams warp ) {\n\n\tfloat noise = fbmNoise3D_3( vec3( pos, warp.anim ), warp.basic );\n\n\tnoise = 1.0 - abs( clamp( noise, -1.0, 1.0 ) );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n// Domain warping by noise derivatives.\n\nvec2 warpDerivatives_0( vec2 pos, WarpParams warp ) {\n\n\tvec4 noise = fmbNoiseDeriv3D_0( vec3( pos, warp.anim ), warp.basic );\n    \n    // noise.x   = noise value\n    // noise.yzw = derivatives (x,y,z)\n    vec2 deriv = vec2( noise.y, noise.z );\n\n\treturn pos + deriv * warp.amplitude;\n}\n\n// Wrapper functions so we can select from the functions at runtime, without having to know the suffix\n// that is added by glslify to the \'require\'d functions, which it does to avoid duplicate identifiers.\nvec2 warpRegular2( vec2 pos, WarpParams warp )       { return warpRegular_1( pos, warp ); }\nvec2 warpPolar2( vec2 pos, WarpParams warp )         { return warpPolar_1( pos, warp ); }\nvec2 warpVortex2( vec2 pos, WarpParams warp )        { return warpVortex_0( pos, warp ); }\nvec2 warpVortexInverse2( vec2 pos, WarpParams warp ) { return warpVortexInverse_1( pos, warp ); }\nvec2 warpDerivatives2( vec2 pos, WarpParams warp )   { return warpDerivatives_0( pos, warp ); }\n\n//·············································································································\n// Noise and transform functions for feedback\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nfloat fbmNoise3D_2( vec3 pos, FbmNoiseParams noise ) {\n\n\tfloat result = 0.0;\n\tfloat amp    = 1.0;\n\tfloat z      = pos.z;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tresult += FB_WARP_NOISE_FUN( vec3( p, z ) ) * amp;\n\n\t\tp   *= rot * noise.lacunarity;\n\t\tamp *= noise.gain;\n\t\tz   += zInc;\n\t\tz   *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tresult += FB_WARP_NOISE_FUN( vec3( p, z ) ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise.\n// This variant returns two different noise values for a given coordinate.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nvec2 fbmNoiseDual3D_2( vec3 pos, FbmNoiseParams noise ) {\n\n\tvec2 result = vec2( 0 );\n\n\tfloat freq = noise.frequency;\n\tfloat z    = pos.z;\n\tfloat amp  = 1.0;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.0;\n\n\t// Randomize noise for Y direction.\n\tconst float yInc = 4.8;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n\t\tvec3 p = vec3( pos.xy * freq, z );\n\t\tfloat nx = FB_WARP_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\t\tfloat ny = FB_WARP_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\t\tresult += vec2( nx, ny ) * amp;\n\n\t\tfreq   *= noise.lacunarity;\n\t\tamp    *= noise.gain;\n\t\tz      += zInc;\n\t\tz      *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\tvec3 p = vec3( pos.xy * freq, z );\n\tfloat nx = FB_WARP_NOISE_FUN( vec3( pos.xy * freq, z ) );\n\tfloat ny = FB_WARP_NOISE_FUN( vec3( pos.xy * freq, z + yInc ) );\n\n\tresult += vec2( nx, ny ) * amp * noise.octavesFract;\n\n\treturn result;\n}\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fractal brownian motion noise and derivatives.\n// This variant also returns the accumulated noise (x) aswell as derivatives of the noise function (yzw), \n// for a given coordinate.\n// Requires NOISE_FUN argument in require() call to define noise function to use.\n\nvec4 fmbNoiseDeriv3D_1( vec3 pos, FbmNoiseParams noise ) {\n\n\tvec4 result = vec4( .0, .0, .0, .0 );\n\tfloat amp   = 1.0;\n\tfloat freq  = 1.0;\n\tfloat z     = pos.z;\n\n\t// Z-increment to "randomize" each octave for avoiding artefacts that originate from coords 0,0\n\t// due to the pseudo-random nature of the noise.\n\t// This value has been choosen by trial and error.\n\tconst float zInc = 7.2;\n\n\tmat2 rot = mat2( cos( noise.angle ), sin( noise.angle ), -sin( noise.angle ), cos( noise.angle ) );\n\n\tvec2 p = pos.xy * noise.frequency;\n\n\t// Create fractal noise by adding multiple octaves of noise.\n\tfor( int i = 0; i < noise.octaves; ++i ) {                \n\n        // Calculate noise (x) and derivatives (y, z, w)\n        vec4 n = FB_WARP_NOISE_DERIV_FUN( vec3( p, z ) ) * amp;\n\n\t\tresult.x   += n.x;           // accumulate noise\n        result.yzw += n.yzw * freq;  // accumulate derivatives \n\n\t\tp    *= rot * noise.lacunarity;\n\t\tamp  *= noise.gain;\n        freq *= noise.lacunarity;\n\t\tz    += zInc;\n\t\tz    *= noise.turbulence;\n\t}\n\n\t// Fractional part of octave value is used for smooth transition.\n\n    vec4 n = FB_WARP_NOISE_DERIV_FUN( vec3( p, z ) ) * amp * noise.octavesFract;\n\n    result.x   += n.x;           // accumulate noise\n    result.yzw += n.yzw * freq;  // accumulate derivatives \n\n\treturn result;\n}\n\n// Regular domain warping. Just offset coordinates by noise values.\n\nvec2 warpRegular_2( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_2( vec3( pos, warp.anim ), warp.basic );\n\t\t\t\t\t\t\t\t\t  \n\treturn pos + noise * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are interpreting the noise values as angle and length to\n// produce more fluid-looking results. \n\nvec2 warpPolar_2( vec2 pos, WarpParams warp ) {\n\n\tvec2 noise = fbmNoiseDual3D_2( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat warpAngle = noise.x * warp.rotation;\n\treturn pos.xy + vec2( sin( warpAngle ), cos( warpAngle ) ) * noise.y * warp.amplitude;\n}\n\n// Most sample code for domain warping simply adds noise values to the fragment position. \n// This is a variation where we are using the noise value for a vortex (spiral) transformation.\n// Creates results similar to warpPolar, but requires only a single noise function, reducing GPU load!\n\nvec2 warpVortex_1( vec2 pos, WarpParams warp ) {\n\t\n\tfloat noise = fbmNoise3D_2( vec3( pos, warp.anim ), warp.basic );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n// Variation of warpVortex. \n\nvec2 warpVortexInverse_0( vec2 pos, WarpParams warp ) {\n\n\tfloat noise = fbmNoise3D_2( vec3( pos, warp.anim ), warp.basic );\n\n\tnoise = 1.0 - abs( clamp( noise, -1.0, 1.0 ) );\n\n\tfloat angle = noise * warp.rotation;\n\tfloat dist  = noise * warp.amplitude;\n\n\treturn pos + vec2( sin( angle ), cos( angle ) ) * dist;\n}\n\n// Domain warping by noise derivatives.\n\nvec2 warpDerivatives_2( vec2 pos, WarpParams warp ) {\n\n\tvec4 noise = fmbNoiseDeriv3D_1( vec3( pos, warp.anim ), warp.basic );\n    \n    // noise.x   = noise value\n    // noise.yzw = derivatives (x,y,z)\n    vec2 deriv = vec2( noise.y, noise.z );\n\n\treturn pos + deriv * warp.amplitude;\n}\n\n// Domain warping by noise derivatives, rotated by 90°, produces cool spirals.\n\nvec2 warpDerivativesOrtho( vec2 pos, WarpParams warp ) {\n\n\tvec4 noise = fmbNoiseDeriv3D_1( vec3( pos, warp.anim ), warp.basic );   \n    // noise.x   = noise value\n    // noise.yzw = derivatives (x,y,z)\n \n    // rotate derivative vector (x,y) by 90° \n    vec2 deriv = vec2( noise.z, -noise.y );\n\n\treturn pos + deriv * warp.amplitude;\n}\n\n// Domain warping by noise derivatives, rotated by 90°, produces cool spirals.\n\nvec2 warpDerivativesOrthoA( vec2 pos, WarpParams warp ) {\n\n\tvec4 noise = fmbNoiseDeriv3D_1( vec3( pos, warp.anim ), warp.basic );   \n    // noise.x   = noise value\n    // noise.yzw = derivatives (x,y,z)\n \n    // rotate derivative vector (x,y) by 90° and multiply by noise for additional effect (reduces rotation at outside of spiral)\n    // TODO: apply optional ease function to noise to fine-tune the result\n    vec2 deriv = vec2( noise.z, -noise.y ) * ( 1.2 - noise.x * noise.x );\n\n\treturn pos + deriv * warp.amplitude;\n}\n\n// Wrapper functions so we can select from the functions at runtime, without having to know the suffix\n// that is added by glslify to the \'require\'d functions, which it does to avoid duplicate identifiers.\nvec2 warpRegularFB( vec2 pos, WarpParams warp )       { return warpRegular_2( pos, warp ); }\nvec2 warpPolarFB( vec2 pos, WarpParams warp )         { return warpPolar_2( pos, warp ); }\nvec2 warpVortexFB( vec2 pos, WarpParams warp )        { return warpVortex_1( pos, warp ); }\nvec2 warpVortexInverseFB( vec2 pos, WarpParams warp ) { return warpVortexInverse_0( pos, warp ); }\nvec2 warpDerivativesFB( vec2 pos, WarpParams warp )   { return warpDerivatives_2( pos, warp ); }\nvec2 warpDerivativesOrthoFB( vec2 pos, WarpParams warp ) { return warpDerivativesOrtho( pos, warp ); }\nvec2 warpDerivativesOrthoAFB( vec2 pos, WarpParams warp ) { return warpDerivativesOrthoA( pos, warp ); }\n\n//·············································································································\n// Color transformation functions\n\nconst mat3 rgb2yiq = mat3( \n\t0.299, 0.587, 0.114, \n\t0.595716, -0.274453, -0.321263, \n\t0.211456, -0.522591, 0.311135 );\n\nconst mat3 yiq2rgb = mat3( \n\t1.0, 0.9563, 0.6210, \n\t1.0, -0.2721, -0.6474, \n\t1.0, -1.1070, 1.7046 );\n\nvec4 hueShift( vec4 color, float value ) {\n    \n    vec3 yColor = rgb2yiq * color.rgb;\n\n    float originalHue = atan( yColor.b, yColor.g );\n    float finalHue = originalHue + value;\n\n    float chroma = sqrt( yColor.b * yColor.b + yColor.g * yColor.g );\n\n    vec3 yFinalColor = vec3( yColor.r, chroma * cos( finalHue ), chroma * sin( finalHue ) );\n \n    return vec4( yiq2rgb * yFinalColor, color.a );\n}\n\nvec4 desaturate( vec4 color, float value ) {\n\tvec3 grayFactors = vec3( 0.3, 0.59, 0.11 );\n\tvec3 gray = vec3( dot( grayFactors, color.rgb ) );\n\tvec3 desatColor = mix( color.rgb, gray, value );\n    return vec4( desatColor, color.a );\n}\n\n//·············································································································\n\nfloat clampZeroOne( float value ) {\n\treturn clamp( value, 0.0, 1.0 );\n}\n\n//·············································································································\n\nfloat mapToPaletteMinusOneToOne( float value ) {\n\treturn value / 2.0 + 0.5;\t\n}\n\n//·············································································································\n// Identity functions to switch off certain effects.\n\nfloat identity( float value ) {\treturn value; }\nvec2 identity( vec2 value ) { return value; }\nvec4 identity( vec4 value ) { return value; }\nvec2 identity( vec2 value, WarpParams warp ) { return value; }\n\n//·············································································································\n// Shader parameters\n\n// Regular noise parameters.\nuniform NoiseParams u_noise;\n\n// Domain warping parameters.\nuniform WarpParams u_warp;\nuniform WarpParams u_warp2;\n\n// Feedback parameters.\nuniform sampler2D  u_feedbackTexture;\nuniform float      u_fbInputBrightness;\nuniform float      u_feedbackBrightness;\nuniform float      u_fbHueShift;\nuniform float      u_fbDesaturate;\nuniform vec2       u_fbTranslate;\nuniform WarpParams u_warpFB;\n\n// Texture that defines the palette.\nuniform sampler2D u_paletteTexture;\nuniform float     u_paletteOffset;      // offset for palette rotation animation\n\n// Fragment coordinates passed in from the vertex shader.\nin vec2 noiseCoord;\nin vec2 feedbackTexCoord;\n\n// Output of this fragment shader.\nout vec4 fragColor;\n\n//·············································································································\n\nvec4 transformColor( vec4 color ) {\n\tcolor = hueShift( color, u_fbHueShift );\n\tcolor = desaturate( color, u_fbDesaturate );\n\treturn color;\n}\n\nvec4 applyFeedback( vec4 color ) {\n\n\tvec2 fbCoord = FB_WARP_TRANSFORM_FUN( feedbackTexCoord, u_warpFB );\n\tfbCoord -= u_fbTranslate;\n\n\tvec4 fbColor = texture( u_feedbackTexture, fbCoord );\n\n\tcolor = color * u_fbInputBrightness + fbColor * u_feedbackBrightness;\n\n\tcolor = FB_COLOR_FUN( color );\n\n\t// TODO: more blending and color transformation functions\n\n\treturn color;\n}\n\n//·············································································································\n\nvoid main() { \n\n\tvec2 pos = noiseCoord;\n\n\tpos = WARP2_TRANSFORM_FUN( pos, u_warp2 );\n\tpos = WARP_TRANSFORM_FUN( pos, u_warp );\n\n\tfloat n = fbmNoise3D_1( vec3( pos, u_noise.anim ), u_noise.basic ) * u_noise.amplitude;\n\t\t\t\t\t\t\n\t// Adjust for differences in noise function range (-1..1 or 0..1).\n\tn = MAP_TO_PALETTE_FUN( n );\n\n\t// Optionally clamp to 0..1\n\tn = NOISE_CLAMP_FUN( n );\n\n\t// Actual color is defined by palette\n\tvec4 color = texture( u_paletteTexture, vec2( n + u_paletteOffset, 0 ) );\n\n\tcolor = FB_APPLY_FUN( color );\n\n\tfragColor = color;\n}',B="#version 300 es\n#define SHADER_NAME glPostVertexShader.glsl\n\nprecision highp float;\n#define GLSLIFY 1\n\n// An attribute is an input (in) to a vertex shader.\n// It will receive data from a buffer.\nin vec2 a_position;\n\n// Used to pass the texture coordinates to the fragment shader\nout vec2 fragCoord;\n\nvoid main() {\n\t// Define position of the current vertex by assigning to global variable gl_Position \n\tgl_Position = vec4( a_position, 0, 1 );\n\n\t// Pass the texture coordinates to the fragment shader.\n\t// Position coords range from -1.0 to 1.0 -> transform to texture range of 0.0 to 1.0.\n\t// The GPU will interpolate this value between points.\n\tfragCoord = vec2( a_position * 0.5 + 0.5 );\n}",V='#version 300 es\n#define SHADER_NAME glPostFragShader.glsl\n\n/*\nPlasmaFractal. Copyright (c) 2019 zett42.\nhttps://github.com/zett42/plasmafractal-gl\n\nMIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE. \n*/\n\n// Fragment shaders don\'t have a default precision so we need to pick one.\nprecision highp float;\nprecision highp sampler2D;\n#define GLSLIFY 1\n\n//·············································································································\n// Shader parameters\n\n// Texture where the noise has been rendered into.\nuniform sampler2D u_renderTexture;\n\n// Final palette texture.\nuniform sampler2D u_paletteFinalTexture;\n\n// Fragment coordinates passed in from the vertex shader.\nin vec2 fragCoord;\n\n// Output of this fragment shader.\nout vec4 fragColor;\n\n//·············································································································\n\nfloat luminance( vec4 color ) {\n    return 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;\n}\n\nvec4 applyPalette( vec4 color ) {\n\treturn texture( u_paletteFinalTexture, vec2( luminance( color ), 0 ) );\n}\n\nvec4 identity( vec4 value ) { return value; }\n\n//·············································································································\n\nvoid main() { \n\n\tvec4 color = texture( u_renderTexture, fragCoord );\n\n\t// Apply final palette if enabled. APPLY_PALETTE_FUN is set from JS to "applyPalette" / "identity".\n\tcolor = APPLY_PALETTE_FUN( color );\n\n    fragColor = color;\n}';function G(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function K(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?G(n,!0).forEach((function(t){Object(l["a"])(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):G(n).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}var q=function(){function e(t){Object(b["a"])(this,e),this._noiseSeed=t.noiseSeed,this._warpSeed=t.warpSeed,this._warpSeed2=t.warpSeed2,this._feedbackSeed=t.feedbackSeed,this._options=P["cloneDeep"](t.options),this._currentTime=0,this._initPalettes(t.colorSeed),this._initCanvasGl(t.canvas),this.resize(t.width,t.height,!0)}return Object(w["a"])(e,[{key:"_initPalettes",value:function(e){this._paletteRndColorCount=2,this._startPalette=[],this._nextPalette=[],this._currentPalette=[],this._currentPaletteFinal=[],this._grayScalePalette=[{pos:0,color:{r:0,g:0,b:0,a:1},easeFun:R["linear"]},{pos:1,color:{r:255,g:255,b:255,a:1},easeFun:R["linear"]}],this._paletteCurrentFirstHue=0,this._colorRnd=new x.a(Math.trunc(4294967295*e)),this._startPalette=this._generatePalette(360*this._colorRnd.random()),this._isPaletteTransition=!1,this._paletteStartTime=0,this._currentPaletteIsRepeat=null}},{key:"_initCanvasGl",value:function(e){this._canvas=e;var t=this._gl=e.getContext("webgl2");t.disable(t.BLEND),t.disable(t.DEPTH_TEST),t.depthMask(t.FALSE),t.stencilMask(t.FALSE),this._extColorBufferFloat=t.getExtension("EXT_color_buffer_float"),console.log("EXT_color_buffer_float:",this._extColorBufferFloat),this._extTextureFloatLinear=t.getExtension("OES_texture_float_linear"),console.log("OES_texture_float_linear:",this._extTextureFloatLinear),this._isFloatTexture=this._extColorBufferFloat&&this._extTextureFloatLinear,this._positionBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this._positionBuffer),z(t,-1,-1,2,2),this._paletteTexture=t.createTexture(),this._paletteFinalTexture=t.createTexture(),this._renderTexture=t.createTexture(),this._feedbackTexture=t.createTexture(),t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this._renderTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.bindTexture(t.TEXTURE_2D,this._feedbackTexture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),this._paletteTextureSize=Math.min(t.getParameter(t.MAX_TEXTURE_SIZE),32768),this._frameBuffer=t.createFramebuffer(),t.bindFramebuffer(t.FRAMEBUFFER,this._frameBuffer),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this._renderTexture,0),this._rebuildShaders()}},{key:"_rebuildShaders",value:function(){var e=function(e,t){return e?t:"identity"},t=S()(W,{BASE_NOISE_FUN:this._options.noise.noiseFunction,NOISE_CLAMP_FUN:e(this._options.noise.isClamp,"clampZeroOne"),MAP_TO_PALETTE_FUN:e("Cellular3D"!=this._options.noise.noiseFunction,"mapToPaletteMinusOneToOne"),WARP_NOISE_FUN:this._options.warp.noiseFunction,WARP_NOISE_DERIV_FUN:"Deriv"+this._options.warp.noiseFunction,WARP_TRANSFORM_FUN:e(this._options.warp.isEnabled,this._options.warp.transformFunction),WARP2_NOISE_FUN:this._options.warp2.noiseFunction,WARP2_NOISE_DERIV_FUN:"Deriv"+this._options.warp2.noiseFunction,WARP2_TRANSFORM_FUN:e(this._options.warp2.isEnabled,"".concat(this._options.warp2.transformFunction,"2")),FB_APPLY_FUN:e(this._options.feedback.isEnabled,"applyFeedback"),FB_COLOR_FUN:e(this._options.feedback.colorTransform.isEnabled,"transformColor"),FB_WARP_NOISE_FUN:this._options.feedback.warp.noiseFunction,FB_WARP_NOISE_DERIV_FUN:"Deriv"+this._options.feedback.warp.noiseFunction,FB_WARP_TRANSFORM_FUN:e(this._options.feedback.warp.isEnabled,"".concat(this._options.feedback.warp.transformFunction,"FB"))});this._plasmaShader=D(this._gl,this._plasmaShader,H,t);var n=S()(V,{APPLY_PALETTE_FUN:e(this._options.paletteFinal.isEnabled,"applyPalette")});this._postShader=D(this._gl,this._postShader,B,n)}},{key:"resize",value:function(e,t){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if((e!=this._canvas.width||t!=this._canvas.height||n)&&!(e<=0||t<=0)){e=Math.trunc(e),t=Math.trunc(t),this._canvas.width=e,this._canvas.height=t;var a=this._gl;a.viewport(0,0,e,t),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,this._renderTexture),this._isFloatTexture?a.texImage2D(a.TEXTURE_2D,0,a.RGBA32F,e,t,0,a.RGBA,a.FLOAT,null):a.texImage2D(a.TEXTURE_2D,0,a.RGBA,e,t,0,a.RGBA,a.UNSIGNED_BYTE,null),a.bindTexture(a.TEXTURE_2D,this._feedbackTexture),this._isFloatTexture?a.texImage2D(a.TEXTURE_2D,0,a.RGBA32F,e,t,0,a.RGBA,a.FLOAT,null):a.texImage2D(a.TEXTURE_2D,0,a.RGBA,e,t,0,a.RGBA,a.UNSIGNED_BYTE,null)}}},{key:"drawAnimationFrame",value:function(e){this._currentTime=e;var t=this._gl;this._plasmaShader.bind();var n=this._canvas.width,a=this._canvas.height;n>a?a>0&&(this._plasmaShader.uniforms.u_scale=[1,a/n]):n>0&&(this._plasmaShader.uniforms.u_scale=[n/a,1]),this.setShaderArgs_noise("u_noise",this._options.noise,this._options.noiseAnim,this._noiseSeed,e),this._options.warp.isEnabled&&this.setShaderArgs_warp("u_warp",this._options.warp,this._options.warpAnim,this._warpSeed,e),this._options.warp2.isEnabled&&this.setShaderArgs_warp("u_warp2",this._options.warp2,this._options.warpAnim2,this._warpSeed2,e),this._options.feedback.isEnabled&&(this._plasmaShader.uniforms.u_fbInputBrightness=this._options.feedback.blending.inputBrightness,this._plasmaShader.uniforms.u_feedbackBrightness=this._options.feedback.blending.feedbackBrightness,this._plasmaShader.uniforms.u_fbHueShift=this._options.feedback.colorTransform.hueShift,this._plasmaShader.uniforms.u_fbDesaturate=this._options.feedback.colorTransform.desaturate,this._options.feedback.transform.isEnabled?this._plasmaShader.uniforms.u_fbTranslate=[.01*this._options.feedback.transform.translateX,.01*this._options.feedback.transform.translateY]:this._plasmaShader.uniforms.u_fbTranslate=[0,0],this._options.feedback.warp.isEnabled&&this.setShaderArgs_warp("u_warpFB",this._options.feedback.warp,this._options.feedbackAnim,this._feedbackSeed,e)),this.setShaderArgs_palette(e),t.bindFramebuffer(t.FRAMEBUFFER,this._frameBuffer),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),this._plasmaShader.uniforms.u_paletteTexture=0,this._plasmaShader.uniforms.u_feedbackTexture=1,t.activeTexture(t.TEXTURE0+this._plasmaShader.uniforms.u_paletteTexture),t.bindTexture(t.TEXTURE_2D,this._paletteTexture),t.activeTexture(t.TEXTURE0+this._plasmaShader.uniforms.u_feedbackTexture),t.bindTexture(t.TEXTURE_2D,this._feedbackTexture),t.bindBuffer(t.ARRAY_BUFFER,this._positionBuffer),this._plasmaShader.attributes.a_position.pointer(),t.drawArrays(t.TRIANGLES,0,6),this._options.feedback.isEnabled&&(t.activeTexture(t.TEXTURE0+this._plasmaShader.uniforms.u_feedbackTexture),t.bindTexture(t.TEXTURE_2D,this._feedbackTexture),t.copyTexSubImage2D(t.TEXTURE_2D,0,0,0,0,0,n,a)),t.bindFramebuffer(t.FRAMEBUFFER,null),t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),this._postShader.bind(),this._postShader.uniforms.u_renderTexture=0,t.activeTexture(t.TEXTURE0+this._postShader.uniforms.u_renderTexture),t.bindTexture(t.TEXTURE_2D,this._renderTexture),this._postShader.uniforms.u_paletteFinalTexture=1,t.activeTexture(t.TEXTURE0+this._postShader.uniforms.u_paletteFinalTexture),t.bindTexture(t.TEXTURE_2D,this._paletteFinalTexture),t.bindBuffer(t.ARRAY_BUFFER,this._positionBuffer),this._postShader.attributes.a_position.pointer(),t.drawArrays(t.TRIANGLES,0,6)}},{key:"setShaderArgs_noise",value:function(e,t,n,a,i){var o=this._plasmaShader.uniforms[e];o.basic.octaves=Math.trunc(this._options.noise.octaves),o.basic.octavesFract=this._options.noise.octaves%1,o.basic.frequency=this._options.noise.frequency/2,o.basic.gain=this._options.noise.gain,o.basic.lacunarity=this._options.noise.lacunarity,o.basic.angle=2*this._options.noise.angle*Math.PI/360,o.amplitude=this._options.noise.amplitude;var r=50*this._noiseSeed,s=1;this._options.noiseAnim.isEnabled&&(r+=i*this._options.noiseAnim.noiseSpeed/3,s=this._options.noiseAnim.turbulence),o.anim=r,o.basic.turbulence=s}},{key:"setShaderArgs_warp",value:function(e,t,n,a,i){var o=this._plasmaShader.uniforms[e];o.basic.octaves=Math.trunc(t.octaves),o.basic.octavesFract=t.octaves%1,o.basic.frequency=t.frequency*this._options.noise.frequency,o.basic.gain=t.gain,o.basic.lacunarity=t.lacunarity,o.amplitude=.01*t.amplitude,o.rotation=t.rotation*Math.PI;var r=50*a,s=1;n.isEnabled&&(r+=i*n.noiseSpeed/3,s=n.turbulence),o.anim=r,o.basic.turbulence=s}},{key:"setShaderArgs_palette",value:function(e){var t=this._gl;if(this._options.paletteAnim.isRotaEnabled&&!this._options.noise.isClamp){var n=this._paletteTextureSize/4096;this._plasmaShader.uniforms.u_paletteOffset=e*this._options.paletteAnim.rotaSpeed*n}else this._plasmaShader.uniforms.u_paletteOffset=0;var a=this._grayScalePalette;this._options.palette.isGrayScale||(a=this._animatePalette());var i=!this._options.noise.isClamp;if(!P["isEqual"]([this._currentPalette,this._currentPaletteIsRepeat],[a,i])){this._currentPalette=P["cloneDeep"](a),this._currentPaletteIsRepeat=i,t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this._paletteTexture);var o=I["f"](a,R);F(t,this._paletteTextureSize,o,i)}if(!P["isEqual"](this._currentPaletteFinal,this._options.paletteFinal)&&(this._currentPaletteFinal=P["cloneDeep"](this._options.paletteFinal),this._options.paletteFinal.isEnabled)){t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this._paletteFinalTexture);var r=!1,s=I["f"](this._options.paletteFinal.customPalette,R);F(t,this._paletteTextureSize,s,r)}}},{key:"_needRebuildShaderForWarpOptions",value:function(e,t){return!P["isEqual"]([e.isEnabled,e.noiseFunction,e.transformFunction],[t.isEnabled,t.noiseFunction,t.transformFunction])}},{key:"_animatePalette",value:function(){var e=this._currentTime,t=e-this._paletteStartTime;if(this._isPaletteTransition){if(t<=this._options.paletteAnim.transitionDuration){var n=t/this._options.paletteAnim.transitionDuration;return I["a"](this._startPalette,this._nextPalette,n)}this._isPaletteTransition=!1,this._paletteStartTime=e;var a=[this._nextPalette,this._startPalette];return this._startPalette=a[0],this._nextPalette=a[1],this._startPalette}return t>this._options.paletteAnim.transitionDelay&&(this._isPaletteTransition=!0,this._paletteStartTime=e,this._nextPalette=this._generatePalette(360*this._colorRnd.random())),this._startPalette}},{key:"_generatePalette",value:function(e){return this._paletteCurrentFirstHue=e,this._options.palette.isCustom?this._generatePaletteCustom(e):this._generatePaletteRandom(e)}},{key:"_generatePaletteCustom",value:function(e){var t=P["cloneDeep"](this._options.palette.customPalette);if(this._options.palette.isCustomPaletteAnimated){var n=!0,a=!1,i=void 0;try{for(var o,r=t[Symbol.iterator]();!(n=(o=r.next()).done);n=!0){var s=o.value,l=T(s.color).toHsv();l.h=(l.h+e)%360,s.color=T(l).toRgb()}}catch(c){a=!0,i=c}finally{try{n||null==r.return||r.return()}finally{if(a)throw i}}}return t}},{key:"_generatePaletteRandom",value:function(e){for(var t=[],n={h:e,s:this._options.palette.saturation,v:this._options.palette.brightness,a:1},a=R[this._options.palette.easeFunctionBgToFg],i=R[this._options.palette.easeFunctionFgToBg],o=1/this._paletteRndColorCount,r=o/2,s=0;s<this._paletteRndColorCount;++s){var l=I["d"](n);t.push({pos:s*o,color:K({},this._options.palette.bgColor),easeFun:a||R["linear"]}),t.push({pos:s*o+r,color:l,easeFun:i||R["linear"]})}return t}},{key:"options$noise",get:function(){return P["cloneDeep"](this._options.noise)},set:function(e){var t=!P["isEqual"]([this._options.noise.noiseFunction,this._options.noise.isClamp],[e.noiseFunction,e.isClamp]);this._options.noise=P["cloneDeep"](e),t&&this._rebuildShaders()}},{key:"options$warp",get:function(){return P["cloneDeep"](this._options.warp)},set:function(e){var t=this._needRebuildShaderForWarpOptions(this._options.warp,e);this._options.warp=P["cloneDeep"](e),t&&this._rebuildShaders()}},{key:"options$warp2",get:function(){return P["cloneDeep"](this._options.warp2)},set:function(e){var t=this._needRebuildShaderForWarpOptions(this._options.warp2,e);this._options.warp2=P["cloneDeep"](e),t&&this._rebuildShaders()}},{key:"options$feedback",get:function(){return P["cloneDeep"](this._options.feedback)},set:function(e){var t=this._options.feedback.isEnabled!=e.isEnabled||this._options.feedback.colorTransform.isEnabled!=e.colorTransform.isEnabled||this._needRebuildShaderForWarpOptions(this._options.feedback.warp,e.warp);this._options.feedback=P["cloneDeep"](e),t&&this._rebuildShaders()}},{key:"options$palette",get:function(){return P["cloneDeep"](this._options.palette)},set:function(e){this._options.palette=P["cloneDeep"](e),this._startPalette=this._generatePalette(this._paletteCurrentFirstHue),this._isPaletteTransition=!1,this._paletteStartTime=this._currentTime}},{key:"options$paletteFinal",get:function(){return P["cloneDeep"](this._options.paletteFinal)},set:function(e){var t=!P["isEqual"](this._options.paletteFinal.isEnabled,e.isEnabled);this._options.paletteFinal=P["cloneDeep"](e),t&&this._rebuildShaders()}},{key:"options$paletteAnim",get:function(){return P["cloneDeep"](this._options.paletteAnim)},set:function(e){e.transitionDelay==this._options.paletteAnim.transitionDelay&&e.transitionDuration==this._options.paletteAnim.transitionDuration||(this._isPaletteTransition=!1,this._paletteStartTime=this._currentTime),this._options.paletteAnim=P["cloneDeep"](e)}},{key:"options$noiseAnim",get:function(){return P["cloneDeep"](this._options.noiseAnim)},set:function(e){this._options.noiseAnim=P["cloneDeep"](e)}},{key:"options$warpAnim",get:function(){return P["cloneDeep"](this._options.warpAnim)},set:function(e){this._options.warpAnim=P["cloneDeep"](e)}},{key:"options$warpAnim2",get:function(){return P["cloneDeep"](this._options.warpAnim2)},set:function(e){this._options.warpAnim2=P["cloneDeep"](e)}},{key:"options$feedbackAnim",get:function(){return P["cloneDeep"](this._options.feedbackAnim)},set:function(e){this._options.feedbackAnim=P["cloneDeep"](e)}}]),e}(),$=y["d"](_,window.location.search),j=null,Y=null,X=null,Z=performance.now(),J=0,Q={name:"app",data:function(){return{optData:$,optDesc:_,optView:g}},mounted:function(){j=document.getElementById("plasmaCanvas"),Y=new q({canvas:j,colorSeed:Math.random(),noiseSeed:Math.random(),warpSeed:Math.random(),warpSeed2:Math.random(),feedbackSeed:Math.random(),options:$,width:Math.round(window.innerWidth*window.devicePixelRatio),height:Math.round(window.innerHeight*window.devicePixelRatio)}),ee(),requestAnimationFrame(re)},methods:{onModified:function(e){P["set"]($,e.path,e.value);var t=e.path.split(".")[0];Y["options$"+t]=$[t]}}};function ee(){window.addEventListener("resize",P["debounce"](le,150)),window.addEventListener("popstate",(function(){return window.location.reload()})),document.addEventListener("fullscreenchange",ue),document.addEventListener("mousemove",ue),document.addEventListener("click",ue),document.addEventListener("keydown",de),j.addEventListener("dblclick",ce)}var te=59.95,ne=1/te,ae=0,ie=0,oe=0;function re(e){requestAnimationFrame(re);var t=e/1e3,n=t-ae;if(n>.25&&(n=.25),ae=t,$.feedback.isEnabled&&$.feedback.lockFPS){ie+=n;while(ie>=ne)Y.drawAnimationFrame(oe),se(),ie-=ne,oe+=ne}else oe=ae,Y.drawAnimationFrame(oe),se()}function se(){++J;var e=performance.now();if(e-Z>=1e3){var t=document.getElementById("fps-info");t&&(t.textContent=J.toFixed(0)+" fps"),Z=e,J=0}}function le(){var e=Math.round(window.innerWidth*window.devicePixelRatio),t=Math.round(window.innerHeight*window.devicePixelRatio);Y.resize(e,t)}function ce(){document.documentElement.requestFullscreen&&(document.fullscreenElement?document.exitFullscreen():document.documentElement.requestFullscreen())}function ue(){document.getElementById("button-options-dialog").style.opacity=1,X&&clearTimeout(X),document.fullscreenElement&&(X=setTimeout((function(){return document.getElementById("button-options-dialog").style.opacity=0}),2e3))}function de(e){if(!e.isComposing)switch(e.keyCode){case"O".charCodeAt(0):document.getElementById("button-options-dialog").click();break}}var he=Q,fe=n("2877"),pe=Object(fe["a"])(he,r,s,!1,null,null,null),ve=pe.exports;n("357f");a["default"].config.productionTip=!1,new a["default"]({render:function(e){return e(ve)}}).$mount("#app")},"93b8":function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-form-group",{attrs:{label:e.optDesc.$attrs.title+": "+e.displayValue,"label-for":e.id,disabled:e.disabled}},[n("div",{staticClass:"z42opt-range",attrs:{id:e.id,disabled:e.disabled}})])},i=[],o=(n("a9e3"),n("d3b7"),n("3ca3"),n("10d1"),n("ddb0"),n("ca11")),r=n("e9fa"),s=n.n(r),l=(n("c0a8"),new WeakMap),c={name:"z42opt-range",inheritAttrs:!1,props:{id:{type:String,required:!0},value:{type:Number,required:!0},optDesc:{type:o["b"],required:!0},disabled:{type:Boolean,required:!1,default:!1}},mounted:function(){var e=this;l.set(this,{sliderValue:this.value});var t=this.getSliderElement();s.a.create(t,this.createSliderConfig());var n=this.optDesc.$attrs.isSlow?"change":"slide";t.noUiSlider.on(n,(function(){return e.onSlide.apply(e,arguments)}))},computed:{displayValue:function(){return this.optDesc.$displayValue(this.value)}},methods:{getSliderElement:function(){return document.getElementById(this.id)},createSliderConfig:function(){var e=this,t=1;null!=this.optDesc.$attrs.step?t=this.optDesc.$attrs.step:null!=this.optDesc.$attrs.maxDecimals&&(t=1/Math.pow(10,this.optDesc.$attrs.maxDecimals));var n={min:this.optDesc.$attrs.min,max:this.optDesc.$attrs.max};if(this.optDesc.$attrs.isScale){var a=50;null!=this.optDesc.$attrs.scaleNormalPos&&(a=100*this.optDesc.$attrs.scaleNormalPos),n["".concat(a,"%")]=1}var i={to:function(t){return e.optDesc.$displayValue(t)}};return{start:[this.value],step:t,range:n,behaviour:"unconstrained",tooltips:!!this.optDesc.$attrs.isSlow&&i}},onSlide:function(e,t,n,a,i){var o=l.get(this),r=n[0];o.sliderValue!==r&&(o.sliderValue=r,this.$emit("input",r))}},watch:{value:function(e,t){var n=l.get(this);if(n.sliderValue!==e){n.sliderValue=e;var a=this.getSliderElement();a.noUiSlider.set([e])}}}},u=c,d=n("2877"),h=Object(d["a"])(u,a,i,!1,null,null,null);t["default"]=h.exports},b8d7:function(e,t,n){var a={"./z42opt-check.vue":"0388","./z42opt-color.vue":"2465","./z42opt-container.vue":"11f2","./z42opt-dialog.vue":"4af1","./z42opt-palette.vue":"0954","./z42opt-range.vue":"93b8","./z42opt-select.vue":"4fc5","./z42opt-tabs.vue":"fc79"};function i(e){var t=o(e);return n(t)}function o(e){if(!n.o(a,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return a[e]}i.keys=function(){return Object.keys(a)},i.resolve=o,e.exports=i,i.id="b8d7"},be4d:function(e,t,n){"use strict";n("d81d"),n("4e82");var a=n("284c"),i=n("66cb"),o=(n("b65f"),n("9f12")),r=n("53fe"),s=function(){function e(t,n,a){Object(o["a"])(this,e),this.x=t,this.y=n,this.z=a}return Object(r["a"])(e,[{key:"dot2",value:function(e,t){return this.x*e+this.y*t}},{key:"dot3",value:function(e,t,n){return this.x*e+this.y*t+this.z*n}}]),e}();function l(e){return e*e*e*(e*(6*e-15)+10)}function c(e,t,n){return(1-n)*e+n*t}var u=[new s(1,1,0),new s(-1,1,0),new s(1,-1,0),new s(-1,-1,0),new s(1,0,1),new s(-1,0,1),new s(1,0,-1),new s(-1,0,-1),new s(0,1,1),new s(0,-1,1),new s(0,1,-1),new s(0,-1,-1)],d=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180],h=.5*(Math.sqrt(3)-1),f=(3-Math.sqrt(3))/6,p=1/3,v=1/6,m=function(){function e(t){Object(o["a"])(this,e),this._perm=new Array(512),this._gradP=new Array(512),this.seed=t}return Object(r["a"])(e,[{key:"simplex2",value:function(e,t){var n,a,i,o,r,s=(e+t)*h,l=Math.floor(e+s),c=Math.floor(t+s),u=(l+c)*f,d=e-l+u,p=t-c+u;d>p?(o=1,r=0):(o=0,r=1);var v=d-o+f,m=p-r+f,_=d-1+2*f,g=p-1+2*f;l&=255,c&=255;var y=this._gradP[l+this._perm[c]],b=this._gradP[l+o+this._perm[c+r]],w=this._gradP[l+1+this._perm[c+1]],E=.5-d*d-p*p;E<0?n=0:(E*=E,n=E*E*y.dot2(d,p));var x=.5-v*v-m*m;x<0?a=0:(x*=x,a=x*x*b.dot2(v,m));var T=.5-_*_-g*g;return T<0?i=0:(T*=T,i=T*T*w.dot2(_,g)),70*(n+a+i)}},{key:"simplex3",value:function(e,t,n){var a,i,o,r,s,l,c,u,d,h,f=(e+t+n)*p,m=Math.floor(e+f),_=Math.floor(t+f),g=Math.floor(n+f),y=(m+_+g)*v,b=e-m+y,w=t-_+y,E=n-g+y;b>=w?w>=E?(s=1,l=0,c=0,u=1,d=1,h=0):b>=E?(s=1,l=0,c=0,u=1,d=0,h=1):(s=0,l=0,c=1,u=1,d=0,h=1):w<E?(s=0,l=0,c=1,u=0,d=1,h=1):b<E?(s=0,l=1,c=0,u=0,d=1,h=1):(s=0,l=1,c=0,u=1,d=1,h=0);var x=b-s+v,T=w-l+v,P=E-c+v,O=b-u+2*v,S=w-d+2*v,I=E-h+2*v,R=b-1+3*v,A=w-1+3*v,N=E-1+3*v;m&=255,_&=255,g&=255;var z=this._gradP[m+this._perm[_+this._perm[g]]],D=this._gradP[m+s+this._perm[_+l+this._perm[g+c]]],F=this._gradP[m+u+this._perm[_+d+this._perm[g+h]]],C=this._gradP[m+1+this._perm[_+1+this._perm[g+1]]],L=.6-b*b-w*w-E*E;L<0?a=0:(L*=L,a=L*L*z.dot3(b,w,E));var M=.6-x*x-T*T-P*P;M<0?i=0:(M*=M,i=M*M*D.dot3(x,T,P));var k=.6-O*O-S*S-I*I;k<0?o=0:(k*=k,o=k*k*F.dot3(O,S,I));var U=.6-R*R-A*A-N*N;return U<0?r=0:(U*=U,r=U*U*C.dot3(R,A,N)),32*(a+i+o+r)}},{key:"perlin2",value:function(e,t){var n=Math.floor(e),a=Math.floor(t);e-=n,t-=a,n&=255,a&=255;var i=this._gradP[n+this._perm[a]].dot2(e,t),o=this._gradP[n+this._perm[a+1]].dot2(e,t-1),r=this._gradP[n+1+this._perm[a]].dot2(e-1,t),s=this._gradP[n+1+this._perm[a+1]].dot2(e-1,t-1),u=l(e);return c(c(i,r,u),c(o,s,u),l(t))}},{key:"perlin3",value:function(e,t,n){var a=Math.floor(e),i=Math.floor(t),o=Math.floor(n);e-=a,t-=i,n-=o,a&=255,i&=255,o&=255;var r=this._gradP[a+this._perm[i+this._perm[o]]].dot3(e,t,n),s=this._gradP[a+this._perm[i+this._perm[o+1]]].dot3(e,t,n-1),u=this._gradP[a+this._perm[i+1+this._perm[o]]].dot3(e,t-1,n),d=this._gradP[a+this._perm[i+1+this._perm[o+1]]].dot3(e,t-1,n-1),h=this._gradP[a+1+this._perm[i+this._perm[o]]].dot3(e-1,t,n),f=this._gradP[a+1+this._perm[i+this._perm[o+1]]].dot3(e-1,t,n-1),p=this._gradP[a+1+this._perm[i+1+this._perm[o]]].dot3(e-1,t-1,n),v=this._gradP[a+1+this._perm[i+1+this._perm[o+1]]].dot3(e-1,t-1,n-1),m=l(e),_=l(t),g=l(n);return c(c(c(r,h,m),c(s,f,m),g),c(c(u,p,m),c(d,v,m),g),_)}},{key:"seed",set:function(e){if(e!==this._seed){this._seed=e,e>0&&e<1&&(e*=65536),e=Math.floor(e),e<256&&(e|=e<<8);for(var t=0;t<256;t++){var n=void 0;n=1&t?d[t]^255&e:d[t]^e>>8&255,this._perm[t]=this._perm[t+256]=n,this._gradP[t]=this._gradP[t+256]=u[n%12]}}},get:function(){return this._seed}}]),e}(),g=n("2aaf"),y=n.n(g),b=function(){function e(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Math.random();Object(o["a"])(this,e),this._noiseGenes=[],this._seed=Math.trunc(4294967295*n),this.octaves=t}return Object(r["a"])(e,[{key:"noise",value:function(e,t){for(var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,r=0,s=n,l=o,c=0;c<this._noiseGenes.length;c++){var u=this._noiseGenes[c].perlin2(e*s,t*s);r+=u*l,l*=a,s*=i}return r}},{key:"octaves",set:function(e){if(e=Math.trunc(e),this._noiseGenes.length!==e){this._noiseGenes.length=e;for(var t=new y.a(this._seed),n=0;n<e;++n){var a=t.random(),i=this._noiseGenes[n];i?i.seed=a:i=this._noiseGenes[n]=new m(a)}}},get:function(){return this._noiseGenes.length}}]),e}();function w(e,t){return e.map((function(e){var n=_.cloneDeep(e);return"function"!==typeof n.easeFun&&(n.easeFun=t[n.easeFun]||t.linear),n}))}function E(e,t,n,a,i,o,r){if(!(n<=0)){n>e.length&&(n=e.length);for(var s=0;s<n;++s){var l=I(s+t,e.length),c={r:o(s,a.r,i.r-a.r,n),g:o(s,a.g,i.g-a.g,n),b:o(s,a.b,i.b-a.b,n),a:o(s,a.a,i.a-a.a,n)},u=r(s/n,c),d=Math.round(u.r),h=Math.round(u.g),f=Math.round(u.b),p=Math.round(255*u.a);e[l]=d|h<<8|f<<16|p<<24}return t+n}}function x(e,t,n){var i=Object(a["a"])(n);i.sort((function(e,t){return e.pos-t.pos}));for(var o=0;o<i.length;++o){var r=(o+1)%i.length,s=i[o],l=i[r],c=s.pos*t,u=l.pos*t,d=Math.round(c),h=Math.round(u),f=h-d;if(r<=o&&(f=t-d+h),f<=0)e[d]=s.color;else{var p=function(e,t){return t};s.isNoisy&&s.noise&&(p=T(s.noise)),E(e,d,f,s.color,l.color,s.easeFun,p)}}}function T(e){var t=new b(e.octaves,e.seed);return function(n,a){var i=0,o=t.noise(n,i,e.frequency,e.gain,e.lacunarity,e.amplitude);return F(a,o)}}function P(e,t,n){if(e.length!=t.length)return console.assert(!1,"Palette arguments must have same size"),null;for(var a=_.cloneDeep(t),i=0;i<e.length;++i)a[i].color=O(e[i].color,t[i].color,n);return a}function O(e,t,n){return{r:Math.round(e.r+(t.r-e.r)*n),g:Math.round(e.g+(t.g-e.g)*n),b:Math.round(e.b+(t.b-e.b)*n),a:Math.round(e.a+(t.a-e.a)*n)}}function S(e){var t=i(e).toRgb(),n=222.4922359499622;return e.h=(e.h+n)%360,t}function I(e,t){return e-t*Math.floor(e/t)}function R(e,t,n){return e<t?t:e>n?n:e}function A(e,t,n){return e+(t-e)*n}function N(e,t,n,a,i){return A(A(e,t,n),a,i)}function z(e){return(Math.max(e.r,e.g,e.b)+Math.min(e.r,e.g,e.b))/255/2}function D(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:z(e);if(n=2*n-1,n<0){if(-1===n)return t*=255,{r:t,g:t,b:t,a:e.a};t=2*t-1;var a=-n,i=-Math.min(t,0),o=(i-a)/(1-a),r=Math.max(t,0);return{r:N(e.r,0,o,255,r),g:N(e.g,0,o,255,r),b:N(e.b,0,o,255,r),a:e.a}}if(1===n)return t*=255,{r:t,g:t,b:t,a:e.a};t=2*t-1;var s=n,l=Math.max(t,0),c=(l-s)/(1-s),u=-Math.min(t,0);return{r:N(e.r,255,c,0,u),g:N(e.g,255,c,0,u),b:N(e.b,255,c,0,u),a:e.a}}function F(e,t){var n=z(e),a=R(n+t,0,1);return D(e,a,n)}n.d(t,"f",(function(){return w})),n.d(t,"e",(function(){return x})),n.d(t,"a",(function(){return P})),n.d(t,"d",(function(){return S})),n.d(t,"c",(function(){return I})),n.d(t,"b",(function(){return R}))},ca11:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return c}));n("0d03"),n("d3b7"),n("25f0");var a=n("53fe"),i=n("8b83"),o=n("c65a"),r=n("c03e"),s=n("9f12"),l=function e(t,n){Object(s["a"])(this,e),Object.defineProperty(this,"$attrs",{enumerable:!1,configurable:!1,writable:!0,value:t}),Object.assign(this,n)},c=function(e){function t(e){return Object(s["a"])(this,t),Object(i["a"])(this,Object(o["a"])(t).call(this,e))}return Object(r["a"])(t,e),Object(a["a"])(t,[{key:"$serialize",value:function(e){return e.toString()}},{key:"$deserialize",value:function(e){return e}},{key:"$displayValue",value:function(e){return e.toString()}},{key:"$parseError",value:function(e){console.error("Invalid option value:",e,", descriptor:",this)}},{key:"$defaultComponent",get:function(){return null}},{key:"$component",get:function(){return this.$attrs.component||this.$defaultComponent}}]),t}(l)},dcbd:function(e,t,n){"use strict";n.r(t),n.d(t,"linear",(function(){return a})),n.d(t,"inQuad",(function(){return i})),n.d(t,"outQuad",(function(){return o})),n.d(t,"inOutQuad",(function(){return r})),n.d(t,"inCubic",(function(){return s})),n.d(t,"outCubic",(function(){return l})),n.d(t,"inOutCubic",(function(){return c})),n.d(t,"inQuart",(function(){return u})),n.d(t,"outQuart",(function(){return d})),n.d(t,"inOutQuart",(function(){return h})),n.d(t,"inQuint",(function(){return f})),n.d(t,"outQuint",(function(){return p})),n.d(t,"inOutQuint",(function(){return v})),n.d(t,"inSine",(function(){return m})),n.d(t,"outSine",(function(){return _})),n.d(t,"inOutSine",(function(){return g})),n.d(t,"inOutSine2_3",(function(){return y})),n.d(t,"inOutSine2_5",(function(){return b})),n.d(t,"inOutSine2_9",(function(){return w})),n.d(t,"inOutSine2_13",(function(){return E})),n.d(t,"inExpo",(function(){return x})),n.d(t,"outExpo",(function(){return T})),n.d(t,"inOutExpo",(function(){return P})),n.d(t,"inExpo2",(function(){return O})),n.d(t,"outExpo2",(function(){return S})),n.d(t,"inOutExpo2",(function(){return I})),n.d(t,"inCirc",(function(){return R})),n.d(t,"outCirc",(function(){return A})),n.d(t,"inOutCirc",(function(){return N})),n.d(t,"inElastic",(function(){return z})),n.d(t,"outElastic",(function(){return D})),n.d(t,"inOutElastic",(function(){return F})),n.d(t,"inBack",(function(){return C})),n.d(t,"outBack",(function(){return L})),n.d(t,"inOutBack",(function(){return M})),n.d(t,"inBounce",(function(){return k})),n.d(t,"outBounce",(function(){return U})),n.d(t,"inOutBounce",(function(){return H}));var a=function(e,t,n,a){return n*e/a+t},i=function(e,t,n,a){return n*(e/=a)*e+t},o=function(e,t,n,a){return-n*(e/=a)*(e-2)+t},r=function(e,t,n,a){return(e/=a/2)<1?n/2*e*e+t:-n/2*(--e*(e-2)-1)+t},s=function(e,t,n,a){return n*(e/=a)*e*e+t},l=function(e,t,n,a){return n*((e=e/a-1)*e*e+1)+t},c=function(e,t,n,a){return(e/=a/2)<1?n/2*e*e*e+t:n/2*((e-=2)*e*e+2)+t},u=function(e,t,n,a){return n*(e/=a)*e*e*e+t},d=function(e,t,n,a){return-n*((e=e/a-1)*e*e*e-1)+t},h=function(e,t,n,a){return(e/=a/2)<1?n/2*e*e*e*e+t:-n/2*((e-=2)*e*e*e-2)+t},f=function(e,t,n,a){return n*(e/=a)*e*e*e*e+t},p=function(e,t,n,a){return n*((e=e/a-1)*e*e*e*e+1)+t},v=function(e,t,n,a){return(e/=a/2)<1?n/2*e*e*e*e*e+t:n/2*((e-=2)*e*e*e*e+2)+t},m=function(e,t,n,a){return-n*Math.cos(e/a*(Math.PI/2))+n+t},_=function(e,t,n,a){return n*Math.sin(e/a*(Math.PI/2))+t},g=function(e,t,n,a){return-n/2*(Math.cos(Math.PI*e/a)-1)+t},y=function(e,t,n,a){return-n/2*(.6*Math.cos(Math.PI*e/a)+.4*Math.cos(Math.PI*e/a*3)-1)+t},b=function(e,t,n,a){return-n/2*(.875*Math.cos(Math.PI*e/a)+.125*Math.cos(Math.PI*e/a*5)-1)+t},w=function(e,t,n,a){return-n/2*(.875*Math.cos(Math.PI*e/a)+.125*Math.cos(Math.PI*e/a*9)-1)+t},E=function(e,t,n,a){return-n/2*(.9*Math.cos(Math.PI*e/a)+.1*Math.cos(Math.PI*e/a*13)-1)+t},x=function(e,t,n,a){return 0==e?t:n*Math.pow(2,10*(e/a-1))+t},T=function(e,t,n,a){return e==a?t+n:n*(1-Math.pow(2,-10*e/a))+t},P=function(e,t,n,a){return 0==e?t:e==a?t+n:(e/=a/2)<1?n/2*Math.pow(2,10*(e-1))+t:n/2*(2-Math.pow(2,-10*--e))+t},O=function(e,t,n,a){return 0==e?t:n*Math.pow(2,20*(e/a-1))+t},S=function(e,t,n,a){return e==a?t+n:n*(1-Math.pow(2,-20*e/a))+t},I=function(e,t,n,a){return 0==e?t:e==a?t+n:(e/=a/2)<1?n/2*Math.pow(2,20*(e-1))+t:n/2*(2-Math.pow(2,-20*--e))+t},R=function(e,t,n,a){return-n*(Math.sqrt(1-(e/=a)*e)-1)+t},A=function(e,t,n,a){return n*Math.sqrt(1-(e=e/a-1)*e)+t},N=function(e,t,n,a){return(e/=a/2)<1?-n/2*(Math.sqrt(1-e*e)-1)+t:n/2*(Math.sqrt(1-(e-=2)*e)+1)+t},z=function(e,t,n,a){var i=1.70158,o=0,r=n;return 0==e?t:1==(e/=a)?t+n:(o||(o=.3*a),r<Math.abs(n)?(r=n,i=o/4):i=o/(2*Math.PI)*Math.asin(n/r),-r*Math.pow(2,10*(e-=1))*Math.sin((e*a-i)*(2*Math.PI)/o)+t)},D=function(e,t,n,a){var i=1.70158,o=0,r=n;return 0==e?t:1==(e/=a)?t+n:(o||(o=.3*a),r<Math.abs(n)?(r=n,i=o/4):i=o/(2*Math.PI)*Math.asin(n/r),r*Math.pow(2,-10*e)*Math.sin((e*a-i)*(2*Math.PI)/o)+n+t)},F=function(e,t,n,a){var i=1.70158,o=0,r=n;return 0==e?t:2==(e/=a/2)?t+n:(o||(o=a*(.3*1.5)),r<Math.abs(n)?(r=n,i=o/4):i=o/(2*Math.PI)*Math.asin(n/r),e<1?r*Math.pow(2,10*(e-=1))*Math.sin((e*a-i)*(2*Math.PI)/o)*-.5+t:r*Math.pow(2,-10*(e-=1))*Math.sin((e*a-i)*(2*Math.PI)/o)*.5+n+t)},C=function(e,t,n,a,i){return void 0==i&&(i=1.70158),n*(e/=a)*e*((i+1)*e-i)+t},L=function(e,t,n,a,i){return void 0==i&&(i=1.70158),n*((e=e/a-1)*e*((i+1)*e+i)+1)+t},M=function(e,t,n,a,i){return void 0==i&&(i=1.70158),(e/=a/2)<1?n/2*(e*e*((1+(i*=1.525))*e-i))+t:n/2*((e-=2)*e*((1+(i*=1.525))*e+i)+2)+t},k=function(e,t,n,a){return n-U(a-e,0,n,a)+t},U=function(e,t,n,a){return(e/=a)<1/2.75?n*(7.5625*e*e)+t:e<2/2.75?n*(7.5625*(e-=1.5/2.75)*e+.75)+t:e<2.5/2.75?n*(7.5625*(e-=2.25/2.75)*e+.9375)+t:n*(7.5625*(e-=2.625/2.75)*e+.984375)+t},H=function(e,t,n,a){return e<a/2?.5*k(2*e,0,n,a)+t:.5*U(2*e-a,0,n,a)+.5*n+t}},fc79:function(e,t,n){"use strict";n.r(t);var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("b-tabs",{attrs:{value:e.tabIndex},on:{input:function(t){return e.$emit("update:tabIndex",t)}}},e._l(e.optView.groups,(function(t,a){return n("b-tab",{key:e.childId(a),attrs:{id:e.childId(a),title:t.title}},[n(e.contentComponentName(t),{tag:"component",staticClass:"container px-0",attrs:{id:e.childId(a),optData:e.optData,optDesc:e.optDesc,optView:t},on:{"opt-modified":function(t){return e.$emit("opt-modified",t)}}})],1)})),1)},i=[],o=(n("a9e3"),n("ca11")),r=n("4752"),s={name:"z42opt-tabs",inheritAttrs:!1,props:{id:{type:String,required:!0},optData:{type:Object,required:!0},optDesc:{type:o["a"],required:!0},optView:{type:Object,required:!0},tabIndex:{type:Number,required:!1,default:0}},methods:{childId:function(e){return r["c"](this.id,e,"#")},contentComponentName:function(e){return e.component?e.component:e.groups?"z42opt-tabs":"z42opt-container"}}},l=s,c=n("2877"),u=Object(c["a"])(l,a,i,!1,null,null,null);t["default"]=u.exports}});
//# sourceMappingURL=app-legacy.1632daa6.js.map